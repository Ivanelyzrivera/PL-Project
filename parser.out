Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    LB
    RB

Grammar

Rule 0     S' -> mainexplist
Rule 1     mainexplist -> explist
Rule 2     mainexplist -> empty
Rule 3     explist -> exp
Rule 4     explist -> exp COMMA explist
Rule 5     exp -> term
Rule 6     exp -> term binop exp
Rule 7     exp -> IF exp THEN exp ELSE exp
Rule 8     exp -> LET def IN exp
Rule 9     exp -> MAP idlist TO exp
Rule 10    term -> unop term
Rule 11    term -> factor
Rule 12    term -> factor LP mainexplist RP
Rule 13    term -> empty
Rule 14    term -> int
Rule 15    term -> string
Rule 16    term -> bool
Rule 17    factor -> LP exp RP
Rule 18    factor -> prim
Rule 19    factor -> id
Rule 20    factor -> string
Rule 21    def -> id ASSIGN exp SC
Rule 22    def -> id ASSIGN exp SC def
Rule 23    idlist -> propidlist
Rule 24    idlist -> empty
Rule 25    propidlist -> id
Rule 26    propidlist -> id COMMA propidlist
Rule 27    bool -> TRUE
Rule 28    bool -> FALSE
Rule 29    unop -> sign
Rule 30    unop -> TILDE
Rule 31    binop -> sign
Rule 32    binop -> TIMES
Rule 33    binop -> DIVIDE
Rule 34    binop -> EQ
Rule 35    binop -> NEQ
Rule 36    binop -> LT
Rule 37    binop -> GT
Rule 38    binop -> LEQ
Rule 39    binop -> GEQ
Rule 40    binop -> AND
Rule 41    binop -> OR
Rule 42    sign -> PLUS
Rule 43    sign -> MINUS
Rule 44    prim -> NUMQ
Rule 45    prim -> FUNQ
Rule 46    prim -> LISTQ
Rule 47    prim -> EMPTYQ
Rule 48    prim -> CONSQ
Rule 49    prim -> CONS
Rule 50    prim -> FIRST
Rule 51    prim -> REST
Rule 52    prim -> ARITY
Rule 53    id -> <empty>
Rule 54    id -> id
Rule 55    id -> int
Rule 56    id -> int id
Rule 57    id -> string
Rule 58    id -> string id
Rule 59    int -> DIGIT
Rule 60    int -> DIGIT int
Rule 61    string -> CHARACTER
Rule 62    string -> CHARACTER string
Rule 63    empty -> <empty>
Rule 64    empty -> EMPTY

Terminals, with rules where they appear

AND                  : 40
ARITY                : 52
ASSIGN               : 21 22
CHARACTER            : 61 62
COMMA                : 4 26
CONS                 : 49
CONSQ                : 48
DIGIT                : 59 60
DIVIDE               : 33
ELSE                 : 7
EMPTY                : 64
EMPTYQ               : 47
EQ                   : 34
FALSE                : 28
FIRST                : 50
FUNQ                 : 45
GEQ                  : 39
GT                   : 37
IF                   : 7
IN                   : 8
LB                   : 
LEQ                  : 38
LET                  : 8
LISTQ                : 46
LP                   : 12 17
LT                   : 36
MAP                  : 9
MINUS                : 43
NEQ                  : 35
NUMQ                 : 44
OR                   : 41
PLUS                 : 42
RB                   : 
REST                 : 51
RP                   : 12 17
SC                   : 21 22
THEN                 : 7
TILDE                : 30
TIMES                : 32
TO                   : 9
TRUE                 : 27
error                : 

Nonterminals, with rules where they appear

binop                : 6
bool                 : 16
def                  : 8 22
empty                : 2 13 24
exp                  : 3 4 6 7 7 7 8 9 17 21 22
explist              : 1 4
factor               : 11 12
id                   : 19 21 22 25 26 54 56 58
idlist               : 9
int                  : 14 55 56 60
mainexplist          : 12 0
prim                 : 18
propidlist           : 23 26
sign                 : 29 31
string               : 15 20 57 58 62
term                 : 5 6 10
unop                 : 10

Parsing method: LALR

state 0

    (0) S' -> . mainexplist
    (1) mainexplist -> . explist
    (2) mainexplist -> . empty
    (3) explist -> . exp
    (4) explist -> . exp COMMA explist
    (63) empty -> .
    (64) empty -> . EMPTY
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
    EMPTY           shift and go to state 5
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)

  ! $end            [ reduce using rule 63 (empty -> .) ]
  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! COMMA           [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    mainexplist                    shift and go to state 1
    explist                        shift and go to state 2
    empty                          shift and go to state 3
    exp                            shift and go to state 4
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 1

    (0) S' -> mainexplist .



state 2

    (1) mainexplist -> explist .

    $end            reduce using rule 1 (mainexplist -> explist .)
    RP              reduce using rule 1 (mainexplist -> explist .)


state 3

    (2) mainexplist -> empty .
    (13) term -> empty .

  ! reduce/reduce conflict for $end resolved using rule 2 (mainexplist -> empty .)
  ! reduce/reduce conflict for RP resolved using rule 2 (mainexplist -> empty .)
    $end            reduce using rule 2 (mainexplist -> empty .)
    RP              reduce using rule 2 (mainexplist -> empty .)
    TIMES           reduce using rule 13 (term -> empty .)
    DIVIDE          reduce using rule 13 (term -> empty .)
    EQ              reduce using rule 13 (term -> empty .)
    NEQ             reduce using rule 13 (term -> empty .)
    LT              reduce using rule 13 (term -> empty .)
    GT              reduce using rule 13 (term -> empty .)
    LEQ             reduce using rule 13 (term -> empty .)
    GEQ             reduce using rule 13 (term -> empty .)
    AND             reduce using rule 13 (term -> empty .)
    OR              reduce using rule 13 (term -> empty .)
    PLUS            reduce using rule 13 (term -> empty .)
    MINUS           reduce using rule 13 (term -> empty .)
    COMMA           reduce using rule 13 (term -> empty .)

  ! $end            [ reduce using rule 13 (term -> empty .) ]
  ! RP              [ reduce using rule 13 (term -> empty .) ]


state 4

    (3) explist -> exp .
    (4) explist -> exp . COMMA explist

    $end            reduce using rule 3 (explist -> exp .)
    RP              reduce using rule 3 (explist -> exp .)
    COMMA           shift and go to state 35


state 5

    (64) empty -> EMPTY .

    $end            reduce using rule 64 (empty -> EMPTY .)
    TIMES           reduce using rule 64 (empty -> EMPTY .)
    DIVIDE          reduce using rule 64 (empty -> EMPTY .)
    EQ              reduce using rule 64 (empty -> EMPTY .)
    NEQ             reduce using rule 64 (empty -> EMPTY .)
    LT              reduce using rule 64 (empty -> EMPTY .)
    GT              reduce using rule 64 (empty -> EMPTY .)
    LEQ             reduce using rule 64 (empty -> EMPTY .)
    GEQ             reduce using rule 64 (empty -> EMPTY .)
    AND             reduce using rule 64 (empty -> EMPTY .)
    OR              reduce using rule 64 (empty -> EMPTY .)
    PLUS            reduce using rule 64 (empty -> EMPTY .)
    MINUS           reduce using rule 64 (empty -> EMPTY .)
    COMMA           reduce using rule 64 (empty -> EMPTY .)
    THEN            reduce using rule 64 (empty -> EMPTY .)
    TO              reduce using rule 64 (empty -> EMPTY .)
    RP              reduce using rule 64 (empty -> EMPTY .)
    ELSE            reduce using rule 64 (empty -> EMPTY .)
    SC              reduce using rule 64 (empty -> EMPTY .)


state 6

    (5) exp -> term .
    (6) exp -> term . binop exp
    (31) binop -> . sign
    (32) binop -> . TIMES
    (33) binop -> . DIVIDE
    (34) binop -> . EQ
    (35) binop -> . NEQ
    (36) binop -> . LT
    (37) binop -> . GT
    (38) binop -> . LEQ
    (39) binop -> . GEQ
    (40) binop -> . AND
    (41) binop -> . OR
    (42) sign -> . PLUS
    (43) sign -> . MINUS

    COMMA           reduce using rule 5 (exp -> term .)
    $end            reduce using rule 5 (exp -> term .)
    THEN            reduce using rule 5 (exp -> term .)
    RP              reduce using rule 5 (exp -> term .)
    ELSE            reduce using rule 5 (exp -> term .)
    SC              reduce using rule 5 (exp -> term .)
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    LT              shift and go to state 42
    GT              shift and go to state 43
    LEQ             shift and go to state 44
    GEQ             shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25

    binop                          shift and go to state 36
    sign                           shift and go to state 37

state 7

    (7) exp -> IF . exp THEN exp ELSE exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for THEN resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    THEN            reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! THEN            [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    exp                            shift and go to state 48
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 8

    (8) exp -> LET . def IN exp
    (21) def -> . id ASSIGN exp SC
    (22) def -> . id ASSIGN exp SC def
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

    ASSIGN          reduce using rule 53 (id -> .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

    def                            shift and go to state 50
    id                             shift and go to state 51
    int                            shift and go to state 52
    string                         shift and go to state 53

state 9

    (9) exp -> MAP . idlist TO exp
    (23) idlist -> . propidlist
    (24) idlist -> . empty
    (25) propidlist -> . id
    (26) propidlist -> . id COMMA propidlist
    (63) empty -> .
    (64) empty -> . EMPTY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

  ! reduce/reduce conflict for TO resolved using rule 53 (id -> .)
    EMPTY           shift and go to state 5
    COMMA           reduce using rule 53 (id -> .)
    TO              reduce using rule 53 (id -> .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

  ! TO              [ reduce using rule 63 (empty -> .) ]

    idlist                         shift and go to state 54
    propidlist                     shift and go to state 55
    empty                          shift and go to state 56
    id                             shift and go to state 57
    int                            shift and go to state 52
    string                         shift and go to state 53

state 10

    (10) term -> unop . term
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for SC resolved using rule 53 (id -> .)
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)
    THEN            reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)
    ELSE            reduce using rule 53 (id -> .)
    SC              reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! COMMA           [ reduce using rule 63 (empty -> .) ]
  ! $end            [ reduce using rule 63 (empty -> .) ]
  ! THEN            [ reduce using rule 63 (empty -> .) ]
  ! RP              [ reduce using rule 63 (empty -> .) ]
  ! ELSE            [ reduce using rule 63 (empty -> .) ]
  ! SC              [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    unop                           shift and go to state 10
    term                           shift and go to state 58
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 11

    (11) term -> factor .
    (12) term -> factor . LP mainexplist RP

    TIMES           reduce using rule 11 (term -> factor .)
    DIVIDE          reduce using rule 11 (term -> factor .)
    EQ              reduce using rule 11 (term -> factor .)
    NEQ             reduce using rule 11 (term -> factor .)
    LT              reduce using rule 11 (term -> factor .)
    GT              reduce using rule 11 (term -> factor .)
    LEQ             reduce using rule 11 (term -> factor .)
    GEQ             reduce using rule 11 (term -> factor .)
    AND             reduce using rule 11 (term -> factor .)
    OR              reduce using rule 11 (term -> factor .)
    PLUS            reduce using rule 11 (term -> factor .)
    MINUS           reduce using rule 11 (term -> factor .)
    COMMA           reduce using rule 11 (term -> factor .)
    $end            reduce using rule 11 (term -> factor .)
    THEN            reduce using rule 11 (term -> factor .)
    RP              reduce using rule 11 (term -> factor .)
    ELSE            reduce using rule 11 (term -> factor .)
    SC              reduce using rule 11 (term -> factor .)
    LP              shift and go to state 59


state 12

    (17) factor -> LP . exp RP
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! RP              [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    exp                            shift and go to state 60
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 13

    (14) term -> int .
    (55) id -> int .
    (56) id -> int . id
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

  ! reduce/reduce conflict for TIMES resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for EQ resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for NEQ resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for LT resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for GT resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for LEQ resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for GEQ resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for AND resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for OR resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for PLUS resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for MINUS resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for COMMA resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for $end resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for THEN resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for RP resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for ELSE resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for SC resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for LP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for EQ resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for NEQ resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for LT resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for GT resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for LEQ resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for GEQ resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for AND resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for OR resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for PLUS resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for MINUS resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for COMMA resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for $end resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for THEN resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for RP resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for ELSE resolved using rule 14 (term -> int .)
  ! reduce/reduce conflict for SC resolved using rule 14 (term -> int .)
    TIMES           reduce using rule 14 (term -> int .)
    DIVIDE          reduce using rule 14 (term -> int .)
    EQ              reduce using rule 14 (term -> int .)
    NEQ             reduce using rule 14 (term -> int .)
    LT              reduce using rule 14 (term -> int .)
    GT              reduce using rule 14 (term -> int .)
    LEQ             reduce using rule 14 (term -> int .)
    GEQ             reduce using rule 14 (term -> int .)
    AND             reduce using rule 14 (term -> int .)
    OR              reduce using rule 14 (term -> int .)
    PLUS            reduce using rule 14 (term -> int .)
    MINUS           reduce using rule 14 (term -> int .)
    COMMA           reduce using rule 14 (term -> int .)
    $end            reduce using rule 14 (term -> int .)
    THEN            reduce using rule 14 (term -> int .)
    RP              reduce using rule 14 (term -> int .)
    ELSE            reduce using rule 14 (term -> int .)
    SC              reduce using rule 14 (term -> int .)
    LP              reduce using rule 53 (id -> .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

  ! LP              [ reduce using rule 55 (id -> int .) ]
  ! TIMES           [ reduce using rule 55 (id -> int .) ]
  ! DIVIDE          [ reduce using rule 55 (id -> int .) ]
  ! EQ              [ reduce using rule 55 (id -> int .) ]
  ! NEQ             [ reduce using rule 55 (id -> int .) ]
  ! LT              [ reduce using rule 55 (id -> int .) ]
  ! GT              [ reduce using rule 55 (id -> int .) ]
  ! LEQ             [ reduce using rule 55 (id -> int .) ]
  ! GEQ             [ reduce using rule 55 (id -> int .) ]
  ! AND             [ reduce using rule 55 (id -> int .) ]
  ! OR              [ reduce using rule 55 (id -> int .) ]
  ! PLUS            [ reduce using rule 55 (id -> int .) ]
  ! MINUS           [ reduce using rule 55 (id -> int .) ]
  ! COMMA           [ reduce using rule 55 (id -> int .) ]
  ! $end            [ reduce using rule 55 (id -> int .) ]
  ! THEN            [ reduce using rule 55 (id -> int .) ]
  ! RP              [ reduce using rule 55 (id -> int .) ]
  ! ELSE            [ reduce using rule 55 (id -> int .) ]
  ! SC              [ reduce using rule 55 (id -> int .) ]
  ! TIMES           [ reduce using rule 53 (id -> .) ]
  ! DIVIDE          [ reduce using rule 53 (id -> .) ]
  ! EQ              [ reduce using rule 53 (id -> .) ]
  ! NEQ             [ reduce using rule 53 (id -> .) ]
  ! LT              [ reduce using rule 53 (id -> .) ]
  ! GT              [ reduce using rule 53 (id -> .) ]
  ! LEQ             [ reduce using rule 53 (id -> .) ]
  ! GEQ             [ reduce using rule 53 (id -> .) ]
  ! AND             [ reduce using rule 53 (id -> .) ]
  ! OR              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]
  ! COMMA           [ reduce using rule 53 (id -> .) ]
  ! $end            [ reduce using rule 53 (id -> .) ]
  ! THEN            [ reduce using rule 53 (id -> .) ]
  ! RP              [ reduce using rule 53 (id -> .) ]
  ! ELSE            [ reduce using rule 53 (id -> .) ]
  ! SC              [ reduce using rule 53 (id -> .) ]

    int                            shift and go to state 52
    id                             shift and go to state 61
    string                         shift and go to state 53

state 14

    (15) term -> string .
    (20) factor -> string .
    (57) id -> string .
    (58) id -> string . id
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

  ! reduce/reduce conflict for TIMES resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for EQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for NEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for LT resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for GT resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for LEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for GEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for AND resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for OR resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for PLUS resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for MINUS resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for COMMA resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for $end resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for THEN resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for RP resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for ELSE resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for SC resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for LP resolved using rule 20 (factor -> string .)
  ! reduce/reduce conflict for TIMES resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for EQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for NEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for LT resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for GT resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for LEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for GEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for AND resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for OR resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for PLUS resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for MINUS resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for COMMA resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for $end resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for THEN resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for RP resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for ELSE resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for SC resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for LP resolved using rule 20 (factor -> string .)
  ! reduce/reduce conflict for TIMES resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for EQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for NEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for LT resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for GT resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for LEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for GEQ resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for AND resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for OR resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for PLUS resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for MINUS resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for COMMA resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for $end resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for THEN resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for RP resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for ELSE resolved using rule 15 (term -> string .)
  ! reduce/reduce conflict for SC resolved using rule 15 (term -> string .)
    TIMES           reduce using rule 15 (term -> string .)
    DIVIDE          reduce using rule 15 (term -> string .)
    EQ              reduce using rule 15 (term -> string .)
    NEQ             reduce using rule 15 (term -> string .)
    LT              reduce using rule 15 (term -> string .)
    GT              reduce using rule 15 (term -> string .)
    LEQ             reduce using rule 15 (term -> string .)
    GEQ             reduce using rule 15 (term -> string .)
    AND             reduce using rule 15 (term -> string .)
    OR              reduce using rule 15 (term -> string .)
    PLUS            reduce using rule 15 (term -> string .)
    MINUS           reduce using rule 15 (term -> string .)
    COMMA           reduce using rule 15 (term -> string .)
    $end            reduce using rule 15 (term -> string .)
    THEN            reduce using rule 15 (term -> string .)
    RP              reduce using rule 15 (term -> string .)
    ELSE            reduce using rule 15 (term -> string .)
    SC              reduce using rule 15 (term -> string .)
    LP              reduce using rule 20 (factor -> string .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

  ! TIMES           [ reduce using rule 20 (factor -> string .) ]
  ! DIVIDE          [ reduce using rule 20 (factor -> string .) ]
  ! EQ              [ reduce using rule 20 (factor -> string .) ]
  ! NEQ             [ reduce using rule 20 (factor -> string .) ]
  ! LT              [ reduce using rule 20 (factor -> string .) ]
  ! GT              [ reduce using rule 20 (factor -> string .) ]
  ! LEQ             [ reduce using rule 20 (factor -> string .) ]
  ! GEQ             [ reduce using rule 20 (factor -> string .) ]
  ! AND             [ reduce using rule 20 (factor -> string .) ]
  ! OR              [ reduce using rule 20 (factor -> string .) ]
  ! PLUS            [ reduce using rule 20 (factor -> string .) ]
  ! MINUS           [ reduce using rule 20 (factor -> string .) ]
  ! COMMA           [ reduce using rule 20 (factor -> string .) ]
  ! $end            [ reduce using rule 20 (factor -> string .) ]
  ! THEN            [ reduce using rule 20 (factor -> string .) ]
  ! RP              [ reduce using rule 20 (factor -> string .) ]
  ! ELSE            [ reduce using rule 20 (factor -> string .) ]
  ! SC              [ reduce using rule 20 (factor -> string .) ]
  ! LP              [ reduce using rule 57 (id -> string .) ]
  ! TIMES           [ reduce using rule 57 (id -> string .) ]
  ! DIVIDE          [ reduce using rule 57 (id -> string .) ]
  ! EQ              [ reduce using rule 57 (id -> string .) ]
  ! NEQ             [ reduce using rule 57 (id -> string .) ]
  ! LT              [ reduce using rule 57 (id -> string .) ]
  ! GT              [ reduce using rule 57 (id -> string .) ]
  ! LEQ             [ reduce using rule 57 (id -> string .) ]
  ! GEQ             [ reduce using rule 57 (id -> string .) ]
  ! AND             [ reduce using rule 57 (id -> string .) ]
  ! OR              [ reduce using rule 57 (id -> string .) ]
  ! PLUS            [ reduce using rule 57 (id -> string .) ]
  ! MINUS           [ reduce using rule 57 (id -> string .) ]
  ! COMMA           [ reduce using rule 57 (id -> string .) ]
  ! $end            [ reduce using rule 57 (id -> string .) ]
  ! THEN            [ reduce using rule 57 (id -> string .) ]
  ! RP              [ reduce using rule 57 (id -> string .) ]
  ! ELSE            [ reduce using rule 57 (id -> string .) ]
  ! SC              [ reduce using rule 57 (id -> string .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! TIMES           [ reduce using rule 53 (id -> .) ]
  ! DIVIDE          [ reduce using rule 53 (id -> .) ]
  ! EQ              [ reduce using rule 53 (id -> .) ]
  ! NEQ             [ reduce using rule 53 (id -> .) ]
  ! LT              [ reduce using rule 53 (id -> .) ]
  ! GT              [ reduce using rule 53 (id -> .) ]
  ! LEQ             [ reduce using rule 53 (id -> .) ]
  ! GEQ             [ reduce using rule 53 (id -> .) ]
  ! AND             [ reduce using rule 53 (id -> .) ]
  ! OR              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]
  ! COMMA           [ reduce using rule 53 (id -> .) ]
  ! $end            [ reduce using rule 53 (id -> .) ]
  ! THEN            [ reduce using rule 53 (id -> .) ]
  ! RP              [ reduce using rule 53 (id -> .) ]
  ! ELSE            [ reduce using rule 53 (id -> .) ]
  ! SC              [ reduce using rule 53 (id -> .) ]

    string                         shift and go to state 53
    id                             shift and go to state 62
    int                            shift and go to state 52

state 15

    (16) term -> bool .

    TIMES           reduce using rule 16 (term -> bool .)
    DIVIDE          reduce using rule 16 (term -> bool .)
    EQ              reduce using rule 16 (term -> bool .)
    NEQ             reduce using rule 16 (term -> bool .)
    LT              reduce using rule 16 (term -> bool .)
    GT              reduce using rule 16 (term -> bool .)
    LEQ             reduce using rule 16 (term -> bool .)
    GEQ             reduce using rule 16 (term -> bool .)
    AND             reduce using rule 16 (term -> bool .)
    OR              reduce using rule 16 (term -> bool .)
    PLUS            reduce using rule 16 (term -> bool .)
    MINUS           reduce using rule 16 (term -> bool .)
    COMMA           reduce using rule 16 (term -> bool .)
    $end            reduce using rule 16 (term -> bool .)
    THEN            reduce using rule 16 (term -> bool .)
    RP              reduce using rule 16 (term -> bool .)
    ELSE            reduce using rule 16 (term -> bool .)
    SC              reduce using rule 16 (term -> bool .)


state 16

    (29) unop -> sign .

    TILDE           reduce using rule 29 (unop -> sign .)
    LP              reduce using rule 29 (unop -> sign .)
    EMPTY           reduce using rule 29 (unop -> sign .)
    DIGIT           reduce using rule 29 (unop -> sign .)
    CHARACTER       reduce using rule 29 (unop -> sign .)
    TRUE            reduce using rule 29 (unop -> sign .)
    FALSE           reduce using rule 29 (unop -> sign .)
    PLUS            reduce using rule 29 (unop -> sign .)
    MINUS           reduce using rule 29 (unop -> sign .)
    NUMQ            reduce using rule 29 (unop -> sign .)
    FUNQ            reduce using rule 29 (unop -> sign .)
    LISTQ           reduce using rule 29 (unop -> sign .)
    EMPTYQ          reduce using rule 29 (unop -> sign .)
    CONSQ           reduce using rule 29 (unop -> sign .)
    CONS            reduce using rule 29 (unop -> sign .)
    FIRST           reduce using rule 29 (unop -> sign .)
    REST            reduce using rule 29 (unop -> sign .)
    ARITY           reduce using rule 29 (unop -> sign .)
    TIMES           reduce using rule 29 (unop -> sign .)
    DIVIDE          reduce using rule 29 (unop -> sign .)
    EQ              reduce using rule 29 (unop -> sign .)
    NEQ             reduce using rule 29 (unop -> sign .)
    LT              reduce using rule 29 (unop -> sign .)
    GT              reduce using rule 29 (unop -> sign .)
    LEQ             reduce using rule 29 (unop -> sign .)
    GEQ             reduce using rule 29 (unop -> sign .)
    AND             reduce using rule 29 (unop -> sign .)
    OR              reduce using rule 29 (unop -> sign .)
    COMMA           reduce using rule 29 (unop -> sign .)
    $end            reduce using rule 29 (unop -> sign .)
    THEN            reduce using rule 29 (unop -> sign .)
    RP              reduce using rule 29 (unop -> sign .)
    ELSE            reduce using rule 29 (unop -> sign .)
    SC              reduce using rule 29 (unop -> sign .)


state 17

    (30) unop -> TILDE .

    TILDE           reduce using rule 30 (unop -> TILDE .)
    LP              reduce using rule 30 (unop -> TILDE .)
    EMPTY           reduce using rule 30 (unop -> TILDE .)
    DIGIT           reduce using rule 30 (unop -> TILDE .)
    CHARACTER       reduce using rule 30 (unop -> TILDE .)
    TRUE            reduce using rule 30 (unop -> TILDE .)
    FALSE           reduce using rule 30 (unop -> TILDE .)
    PLUS            reduce using rule 30 (unop -> TILDE .)
    MINUS           reduce using rule 30 (unop -> TILDE .)
    NUMQ            reduce using rule 30 (unop -> TILDE .)
    FUNQ            reduce using rule 30 (unop -> TILDE .)
    LISTQ           reduce using rule 30 (unop -> TILDE .)
    EMPTYQ          reduce using rule 30 (unop -> TILDE .)
    CONSQ           reduce using rule 30 (unop -> TILDE .)
    CONS            reduce using rule 30 (unop -> TILDE .)
    FIRST           reduce using rule 30 (unop -> TILDE .)
    REST            reduce using rule 30 (unop -> TILDE .)
    ARITY           reduce using rule 30 (unop -> TILDE .)
    TIMES           reduce using rule 30 (unop -> TILDE .)
    DIVIDE          reduce using rule 30 (unop -> TILDE .)
    EQ              reduce using rule 30 (unop -> TILDE .)
    NEQ             reduce using rule 30 (unop -> TILDE .)
    LT              reduce using rule 30 (unop -> TILDE .)
    GT              reduce using rule 30 (unop -> TILDE .)
    LEQ             reduce using rule 30 (unop -> TILDE .)
    GEQ             reduce using rule 30 (unop -> TILDE .)
    AND             reduce using rule 30 (unop -> TILDE .)
    OR              reduce using rule 30 (unop -> TILDE .)
    COMMA           reduce using rule 30 (unop -> TILDE .)
    $end            reduce using rule 30 (unop -> TILDE .)
    THEN            reduce using rule 30 (unop -> TILDE .)
    RP              reduce using rule 30 (unop -> TILDE .)
    ELSE            reduce using rule 30 (unop -> TILDE .)
    SC              reduce using rule 30 (unop -> TILDE .)


state 18

    (18) factor -> prim .

    LP              reduce using rule 18 (factor -> prim .)
    TIMES           reduce using rule 18 (factor -> prim .)
    DIVIDE          reduce using rule 18 (factor -> prim .)
    EQ              reduce using rule 18 (factor -> prim .)
    NEQ             reduce using rule 18 (factor -> prim .)
    LT              reduce using rule 18 (factor -> prim .)
    GT              reduce using rule 18 (factor -> prim .)
    LEQ             reduce using rule 18 (factor -> prim .)
    GEQ             reduce using rule 18 (factor -> prim .)
    AND             reduce using rule 18 (factor -> prim .)
    OR              reduce using rule 18 (factor -> prim .)
    PLUS            reduce using rule 18 (factor -> prim .)
    MINUS           reduce using rule 18 (factor -> prim .)
    COMMA           reduce using rule 18 (factor -> prim .)
    $end            reduce using rule 18 (factor -> prim .)
    THEN            reduce using rule 18 (factor -> prim .)
    RP              reduce using rule 18 (factor -> prim .)
    ELSE            reduce using rule 18 (factor -> prim .)
    SC              reduce using rule 18 (factor -> prim .)


state 19

    (19) factor -> id .
    (54) id -> id .

  ! reduce/reduce conflict for LP resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for TIMES resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for EQ resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for NEQ resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for LT resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for GT resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for LEQ resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for GEQ resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for AND resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for OR resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for PLUS resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for MINUS resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for COMMA resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for $end resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for THEN resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for RP resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (factor -> id .)
  ! reduce/reduce conflict for SC resolved using rule 19 (factor -> id .)
    LP              reduce using rule 19 (factor -> id .)
    TIMES           reduce using rule 19 (factor -> id .)
    DIVIDE          reduce using rule 19 (factor -> id .)
    EQ              reduce using rule 19 (factor -> id .)
    NEQ             reduce using rule 19 (factor -> id .)
    LT              reduce using rule 19 (factor -> id .)
    GT              reduce using rule 19 (factor -> id .)
    LEQ             reduce using rule 19 (factor -> id .)
    GEQ             reduce using rule 19 (factor -> id .)
    AND             reduce using rule 19 (factor -> id .)
    OR              reduce using rule 19 (factor -> id .)
    PLUS            reduce using rule 19 (factor -> id .)
    MINUS           reduce using rule 19 (factor -> id .)
    COMMA           reduce using rule 19 (factor -> id .)
    $end            reduce using rule 19 (factor -> id .)
    THEN            reduce using rule 19 (factor -> id .)
    RP              reduce using rule 19 (factor -> id .)
    ELSE            reduce using rule 19 (factor -> id .)
    SC              reduce using rule 19 (factor -> id .)

  ! LP              [ reduce using rule 54 (id -> id .) ]
  ! TIMES           [ reduce using rule 54 (id -> id .) ]
  ! DIVIDE          [ reduce using rule 54 (id -> id .) ]
  ! EQ              [ reduce using rule 54 (id -> id .) ]
  ! NEQ             [ reduce using rule 54 (id -> id .) ]
  ! LT              [ reduce using rule 54 (id -> id .) ]
  ! GT              [ reduce using rule 54 (id -> id .) ]
  ! LEQ             [ reduce using rule 54 (id -> id .) ]
  ! GEQ             [ reduce using rule 54 (id -> id .) ]
  ! AND             [ reduce using rule 54 (id -> id .) ]
  ! OR              [ reduce using rule 54 (id -> id .) ]
  ! PLUS            [ reduce using rule 54 (id -> id .) ]
  ! MINUS           [ reduce using rule 54 (id -> id .) ]
  ! COMMA           [ reduce using rule 54 (id -> id .) ]
  ! $end            [ reduce using rule 54 (id -> id .) ]
  ! THEN            [ reduce using rule 54 (id -> id .) ]
  ! RP              [ reduce using rule 54 (id -> id .) ]
  ! ELSE            [ reduce using rule 54 (id -> id .) ]
  ! SC              [ reduce using rule 54 (id -> id .) ]


state 20

    (59) int -> DIGIT .
    (60) int -> DIGIT . int
    (59) int -> . DIGIT
    (60) int -> . DIGIT int

  ! shift/reduce conflict for DIGIT resolved as shift
    CHARACTER       reduce using rule 59 (int -> DIGIT .)
    TIMES           reduce using rule 59 (int -> DIGIT .)
    DIVIDE          reduce using rule 59 (int -> DIGIT .)
    EQ              reduce using rule 59 (int -> DIGIT .)
    NEQ             reduce using rule 59 (int -> DIGIT .)
    LT              reduce using rule 59 (int -> DIGIT .)
    GT              reduce using rule 59 (int -> DIGIT .)
    LEQ             reduce using rule 59 (int -> DIGIT .)
    GEQ             reduce using rule 59 (int -> DIGIT .)
    AND             reduce using rule 59 (int -> DIGIT .)
    OR              reduce using rule 59 (int -> DIGIT .)
    PLUS            reduce using rule 59 (int -> DIGIT .)
    MINUS           reduce using rule 59 (int -> DIGIT .)
    COMMA           reduce using rule 59 (int -> DIGIT .)
    $end            reduce using rule 59 (int -> DIGIT .)
    LP              reduce using rule 59 (int -> DIGIT .)
    THEN            reduce using rule 59 (int -> DIGIT .)
    ASSIGN          reduce using rule 59 (int -> DIGIT .)
    TO              reduce using rule 59 (int -> DIGIT .)
    RP              reduce using rule 59 (int -> DIGIT .)
    ELSE            reduce using rule 59 (int -> DIGIT .)
    SC              reduce using rule 59 (int -> DIGIT .)
    DIGIT           shift and go to state 20

  ! DIGIT           [ reduce using rule 59 (int -> DIGIT .) ]

    int                            shift and go to state 63

state 21

    (61) string -> CHARACTER .
    (62) string -> CHARACTER . string
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

  ! shift/reduce conflict for CHARACTER resolved as shift
    DIGIT           reduce using rule 61 (string -> CHARACTER .)
    TIMES           reduce using rule 61 (string -> CHARACTER .)
    DIVIDE          reduce using rule 61 (string -> CHARACTER .)
    EQ              reduce using rule 61 (string -> CHARACTER .)
    NEQ             reduce using rule 61 (string -> CHARACTER .)
    LT              reduce using rule 61 (string -> CHARACTER .)
    GT              reduce using rule 61 (string -> CHARACTER .)
    LEQ             reduce using rule 61 (string -> CHARACTER .)
    GEQ             reduce using rule 61 (string -> CHARACTER .)
    AND             reduce using rule 61 (string -> CHARACTER .)
    OR              reduce using rule 61 (string -> CHARACTER .)
    PLUS            reduce using rule 61 (string -> CHARACTER .)
    MINUS           reduce using rule 61 (string -> CHARACTER .)
    COMMA           reduce using rule 61 (string -> CHARACTER .)
    $end            reduce using rule 61 (string -> CHARACTER .)
    LP              reduce using rule 61 (string -> CHARACTER .)
    THEN            reduce using rule 61 (string -> CHARACTER .)
    ASSIGN          reduce using rule 61 (string -> CHARACTER .)
    TO              reduce using rule 61 (string -> CHARACTER .)
    RP              reduce using rule 61 (string -> CHARACTER .)
    ELSE            reduce using rule 61 (string -> CHARACTER .)
    SC              reduce using rule 61 (string -> CHARACTER .)
    CHARACTER       shift and go to state 21

  ! CHARACTER       [ reduce using rule 61 (string -> CHARACTER .) ]

    string                         shift and go to state 64

state 22

    (27) bool -> TRUE .

    TIMES           reduce using rule 27 (bool -> TRUE .)
    DIVIDE          reduce using rule 27 (bool -> TRUE .)
    EQ              reduce using rule 27 (bool -> TRUE .)
    NEQ             reduce using rule 27 (bool -> TRUE .)
    LT              reduce using rule 27 (bool -> TRUE .)
    GT              reduce using rule 27 (bool -> TRUE .)
    LEQ             reduce using rule 27 (bool -> TRUE .)
    GEQ             reduce using rule 27 (bool -> TRUE .)
    AND             reduce using rule 27 (bool -> TRUE .)
    OR              reduce using rule 27 (bool -> TRUE .)
    PLUS            reduce using rule 27 (bool -> TRUE .)
    MINUS           reduce using rule 27 (bool -> TRUE .)
    COMMA           reduce using rule 27 (bool -> TRUE .)
    $end            reduce using rule 27 (bool -> TRUE .)
    THEN            reduce using rule 27 (bool -> TRUE .)
    RP              reduce using rule 27 (bool -> TRUE .)
    ELSE            reduce using rule 27 (bool -> TRUE .)
    SC              reduce using rule 27 (bool -> TRUE .)


state 23

    (28) bool -> FALSE .

    TIMES           reduce using rule 28 (bool -> FALSE .)
    DIVIDE          reduce using rule 28 (bool -> FALSE .)
    EQ              reduce using rule 28 (bool -> FALSE .)
    NEQ             reduce using rule 28 (bool -> FALSE .)
    LT              reduce using rule 28 (bool -> FALSE .)
    GT              reduce using rule 28 (bool -> FALSE .)
    LEQ             reduce using rule 28 (bool -> FALSE .)
    GEQ             reduce using rule 28 (bool -> FALSE .)
    AND             reduce using rule 28 (bool -> FALSE .)
    OR              reduce using rule 28 (bool -> FALSE .)
    PLUS            reduce using rule 28 (bool -> FALSE .)
    MINUS           reduce using rule 28 (bool -> FALSE .)
    COMMA           reduce using rule 28 (bool -> FALSE .)
    $end            reduce using rule 28 (bool -> FALSE .)
    THEN            reduce using rule 28 (bool -> FALSE .)
    RP              reduce using rule 28 (bool -> FALSE .)
    ELSE            reduce using rule 28 (bool -> FALSE .)
    SC              reduce using rule 28 (bool -> FALSE .)


state 24

    (42) sign -> PLUS .

    TILDE           reduce using rule 42 (sign -> PLUS .)
    LP              reduce using rule 42 (sign -> PLUS .)
    EMPTY           reduce using rule 42 (sign -> PLUS .)
    DIGIT           reduce using rule 42 (sign -> PLUS .)
    CHARACTER       reduce using rule 42 (sign -> PLUS .)
    TRUE            reduce using rule 42 (sign -> PLUS .)
    FALSE           reduce using rule 42 (sign -> PLUS .)
    PLUS            reduce using rule 42 (sign -> PLUS .)
    MINUS           reduce using rule 42 (sign -> PLUS .)
    NUMQ            reduce using rule 42 (sign -> PLUS .)
    FUNQ            reduce using rule 42 (sign -> PLUS .)
    LISTQ           reduce using rule 42 (sign -> PLUS .)
    EMPTYQ          reduce using rule 42 (sign -> PLUS .)
    CONSQ           reduce using rule 42 (sign -> PLUS .)
    CONS            reduce using rule 42 (sign -> PLUS .)
    FIRST           reduce using rule 42 (sign -> PLUS .)
    REST            reduce using rule 42 (sign -> PLUS .)
    ARITY           reduce using rule 42 (sign -> PLUS .)
    TIMES           reduce using rule 42 (sign -> PLUS .)
    DIVIDE          reduce using rule 42 (sign -> PLUS .)
    EQ              reduce using rule 42 (sign -> PLUS .)
    NEQ             reduce using rule 42 (sign -> PLUS .)
    LT              reduce using rule 42 (sign -> PLUS .)
    GT              reduce using rule 42 (sign -> PLUS .)
    LEQ             reduce using rule 42 (sign -> PLUS .)
    GEQ             reduce using rule 42 (sign -> PLUS .)
    AND             reduce using rule 42 (sign -> PLUS .)
    OR              reduce using rule 42 (sign -> PLUS .)
    COMMA           reduce using rule 42 (sign -> PLUS .)
    $end            reduce using rule 42 (sign -> PLUS .)
    IF              reduce using rule 42 (sign -> PLUS .)
    LET             reduce using rule 42 (sign -> PLUS .)
    MAP             reduce using rule 42 (sign -> PLUS .)
    THEN            reduce using rule 42 (sign -> PLUS .)
    RP              reduce using rule 42 (sign -> PLUS .)
    ELSE            reduce using rule 42 (sign -> PLUS .)
    SC              reduce using rule 42 (sign -> PLUS .)


state 25

    (43) sign -> MINUS .

    TILDE           reduce using rule 43 (sign -> MINUS .)
    LP              reduce using rule 43 (sign -> MINUS .)
    EMPTY           reduce using rule 43 (sign -> MINUS .)
    DIGIT           reduce using rule 43 (sign -> MINUS .)
    CHARACTER       reduce using rule 43 (sign -> MINUS .)
    TRUE            reduce using rule 43 (sign -> MINUS .)
    FALSE           reduce using rule 43 (sign -> MINUS .)
    PLUS            reduce using rule 43 (sign -> MINUS .)
    MINUS           reduce using rule 43 (sign -> MINUS .)
    NUMQ            reduce using rule 43 (sign -> MINUS .)
    FUNQ            reduce using rule 43 (sign -> MINUS .)
    LISTQ           reduce using rule 43 (sign -> MINUS .)
    EMPTYQ          reduce using rule 43 (sign -> MINUS .)
    CONSQ           reduce using rule 43 (sign -> MINUS .)
    CONS            reduce using rule 43 (sign -> MINUS .)
    FIRST           reduce using rule 43 (sign -> MINUS .)
    REST            reduce using rule 43 (sign -> MINUS .)
    ARITY           reduce using rule 43 (sign -> MINUS .)
    TIMES           reduce using rule 43 (sign -> MINUS .)
    DIVIDE          reduce using rule 43 (sign -> MINUS .)
    EQ              reduce using rule 43 (sign -> MINUS .)
    NEQ             reduce using rule 43 (sign -> MINUS .)
    LT              reduce using rule 43 (sign -> MINUS .)
    GT              reduce using rule 43 (sign -> MINUS .)
    LEQ             reduce using rule 43 (sign -> MINUS .)
    GEQ             reduce using rule 43 (sign -> MINUS .)
    AND             reduce using rule 43 (sign -> MINUS .)
    OR              reduce using rule 43 (sign -> MINUS .)
    COMMA           reduce using rule 43 (sign -> MINUS .)
    $end            reduce using rule 43 (sign -> MINUS .)
    IF              reduce using rule 43 (sign -> MINUS .)
    LET             reduce using rule 43 (sign -> MINUS .)
    MAP             reduce using rule 43 (sign -> MINUS .)
    THEN            reduce using rule 43 (sign -> MINUS .)
    RP              reduce using rule 43 (sign -> MINUS .)
    ELSE            reduce using rule 43 (sign -> MINUS .)
    SC              reduce using rule 43 (sign -> MINUS .)


state 26

    (44) prim -> NUMQ .

    LP              reduce using rule 44 (prim -> NUMQ .)
    TIMES           reduce using rule 44 (prim -> NUMQ .)
    DIVIDE          reduce using rule 44 (prim -> NUMQ .)
    EQ              reduce using rule 44 (prim -> NUMQ .)
    NEQ             reduce using rule 44 (prim -> NUMQ .)
    LT              reduce using rule 44 (prim -> NUMQ .)
    GT              reduce using rule 44 (prim -> NUMQ .)
    LEQ             reduce using rule 44 (prim -> NUMQ .)
    GEQ             reduce using rule 44 (prim -> NUMQ .)
    AND             reduce using rule 44 (prim -> NUMQ .)
    OR              reduce using rule 44 (prim -> NUMQ .)
    PLUS            reduce using rule 44 (prim -> NUMQ .)
    MINUS           reduce using rule 44 (prim -> NUMQ .)
    COMMA           reduce using rule 44 (prim -> NUMQ .)
    $end            reduce using rule 44 (prim -> NUMQ .)
    THEN            reduce using rule 44 (prim -> NUMQ .)
    RP              reduce using rule 44 (prim -> NUMQ .)
    ELSE            reduce using rule 44 (prim -> NUMQ .)
    SC              reduce using rule 44 (prim -> NUMQ .)


state 27

    (45) prim -> FUNQ .

    LP              reduce using rule 45 (prim -> FUNQ .)
    TIMES           reduce using rule 45 (prim -> FUNQ .)
    DIVIDE          reduce using rule 45 (prim -> FUNQ .)
    EQ              reduce using rule 45 (prim -> FUNQ .)
    NEQ             reduce using rule 45 (prim -> FUNQ .)
    LT              reduce using rule 45 (prim -> FUNQ .)
    GT              reduce using rule 45 (prim -> FUNQ .)
    LEQ             reduce using rule 45 (prim -> FUNQ .)
    GEQ             reduce using rule 45 (prim -> FUNQ .)
    AND             reduce using rule 45 (prim -> FUNQ .)
    OR              reduce using rule 45 (prim -> FUNQ .)
    PLUS            reduce using rule 45 (prim -> FUNQ .)
    MINUS           reduce using rule 45 (prim -> FUNQ .)
    COMMA           reduce using rule 45 (prim -> FUNQ .)
    $end            reduce using rule 45 (prim -> FUNQ .)
    THEN            reduce using rule 45 (prim -> FUNQ .)
    RP              reduce using rule 45 (prim -> FUNQ .)
    ELSE            reduce using rule 45 (prim -> FUNQ .)
    SC              reduce using rule 45 (prim -> FUNQ .)


state 28

    (46) prim -> LISTQ .

    LP              reduce using rule 46 (prim -> LISTQ .)
    TIMES           reduce using rule 46 (prim -> LISTQ .)
    DIVIDE          reduce using rule 46 (prim -> LISTQ .)
    EQ              reduce using rule 46 (prim -> LISTQ .)
    NEQ             reduce using rule 46 (prim -> LISTQ .)
    LT              reduce using rule 46 (prim -> LISTQ .)
    GT              reduce using rule 46 (prim -> LISTQ .)
    LEQ             reduce using rule 46 (prim -> LISTQ .)
    GEQ             reduce using rule 46 (prim -> LISTQ .)
    AND             reduce using rule 46 (prim -> LISTQ .)
    OR              reduce using rule 46 (prim -> LISTQ .)
    PLUS            reduce using rule 46 (prim -> LISTQ .)
    MINUS           reduce using rule 46 (prim -> LISTQ .)
    COMMA           reduce using rule 46 (prim -> LISTQ .)
    $end            reduce using rule 46 (prim -> LISTQ .)
    THEN            reduce using rule 46 (prim -> LISTQ .)
    RP              reduce using rule 46 (prim -> LISTQ .)
    ELSE            reduce using rule 46 (prim -> LISTQ .)
    SC              reduce using rule 46 (prim -> LISTQ .)


state 29

    (47) prim -> EMPTYQ .

    LP              reduce using rule 47 (prim -> EMPTYQ .)
    TIMES           reduce using rule 47 (prim -> EMPTYQ .)
    DIVIDE          reduce using rule 47 (prim -> EMPTYQ .)
    EQ              reduce using rule 47 (prim -> EMPTYQ .)
    NEQ             reduce using rule 47 (prim -> EMPTYQ .)
    LT              reduce using rule 47 (prim -> EMPTYQ .)
    GT              reduce using rule 47 (prim -> EMPTYQ .)
    LEQ             reduce using rule 47 (prim -> EMPTYQ .)
    GEQ             reduce using rule 47 (prim -> EMPTYQ .)
    AND             reduce using rule 47 (prim -> EMPTYQ .)
    OR              reduce using rule 47 (prim -> EMPTYQ .)
    PLUS            reduce using rule 47 (prim -> EMPTYQ .)
    MINUS           reduce using rule 47 (prim -> EMPTYQ .)
    COMMA           reduce using rule 47 (prim -> EMPTYQ .)
    $end            reduce using rule 47 (prim -> EMPTYQ .)
    THEN            reduce using rule 47 (prim -> EMPTYQ .)
    RP              reduce using rule 47 (prim -> EMPTYQ .)
    ELSE            reduce using rule 47 (prim -> EMPTYQ .)
    SC              reduce using rule 47 (prim -> EMPTYQ .)


state 30

    (48) prim -> CONSQ .

    LP              reduce using rule 48 (prim -> CONSQ .)
    TIMES           reduce using rule 48 (prim -> CONSQ .)
    DIVIDE          reduce using rule 48 (prim -> CONSQ .)
    EQ              reduce using rule 48 (prim -> CONSQ .)
    NEQ             reduce using rule 48 (prim -> CONSQ .)
    LT              reduce using rule 48 (prim -> CONSQ .)
    GT              reduce using rule 48 (prim -> CONSQ .)
    LEQ             reduce using rule 48 (prim -> CONSQ .)
    GEQ             reduce using rule 48 (prim -> CONSQ .)
    AND             reduce using rule 48 (prim -> CONSQ .)
    OR              reduce using rule 48 (prim -> CONSQ .)
    PLUS            reduce using rule 48 (prim -> CONSQ .)
    MINUS           reduce using rule 48 (prim -> CONSQ .)
    COMMA           reduce using rule 48 (prim -> CONSQ .)
    $end            reduce using rule 48 (prim -> CONSQ .)
    THEN            reduce using rule 48 (prim -> CONSQ .)
    RP              reduce using rule 48 (prim -> CONSQ .)
    ELSE            reduce using rule 48 (prim -> CONSQ .)
    SC              reduce using rule 48 (prim -> CONSQ .)


state 31

    (49) prim -> CONS .

    LP              reduce using rule 49 (prim -> CONS .)
    TIMES           reduce using rule 49 (prim -> CONS .)
    DIVIDE          reduce using rule 49 (prim -> CONS .)
    EQ              reduce using rule 49 (prim -> CONS .)
    NEQ             reduce using rule 49 (prim -> CONS .)
    LT              reduce using rule 49 (prim -> CONS .)
    GT              reduce using rule 49 (prim -> CONS .)
    LEQ             reduce using rule 49 (prim -> CONS .)
    GEQ             reduce using rule 49 (prim -> CONS .)
    AND             reduce using rule 49 (prim -> CONS .)
    OR              reduce using rule 49 (prim -> CONS .)
    PLUS            reduce using rule 49 (prim -> CONS .)
    MINUS           reduce using rule 49 (prim -> CONS .)
    COMMA           reduce using rule 49 (prim -> CONS .)
    $end            reduce using rule 49 (prim -> CONS .)
    THEN            reduce using rule 49 (prim -> CONS .)
    RP              reduce using rule 49 (prim -> CONS .)
    ELSE            reduce using rule 49 (prim -> CONS .)
    SC              reduce using rule 49 (prim -> CONS .)


state 32

    (50) prim -> FIRST .

    LP              reduce using rule 50 (prim -> FIRST .)
    TIMES           reduce using rule 50 (prim -> FIRST .)
    DIVIDE          reduce using rule 50 (prim -> FIRST .)
    EQ              reduce using rule 50 (prim -> FIRST .)
    NEQ             reduce using rule 50 (prim -> FIRST .)
    LT              reduce using rule 50 (prim -> FIRST .)
    GT              reduce using rule 50 (prim -> FIRST .)
    LEQ             reduce using rule 50 (prim -> FIRST .)
    GEQ             reduce using rule 50 (prim -> FIRST .)
    AND             reduce using rule 50 (prim -> FIRST .)
    OR              reduce using rule 50 (prim -> FIRST .)
    PLUS            reduce using rule 50 (prim -> FIRST .)
    MINUS           reduce using rule 50 (prim -> FIRST .)
    COMMA           reduce using rule 50 (prim -> FIRST .)
    $end            reduce using rule 50 (prim -> FIRST .)
    THEN            reduce using rule 50 (prim -> FIRST .)
    RP              reduce using rule 50 (prim -> FIRST .)
    ELSE            reduce using rule 50 (prim -> FIRST .)
    SC              reduce using rule 50 (prim -> FIRST .)


state 33

    (51) prim -> REST .

    LP              reduce using rule 51 (prim -> REST .)
    TIMES           reduce using rule 51 (prim -> REST .)
    DIVIDE          reduce using rule 51 (prim -> REST .)
    EQ              reduce using rule 51 (prim -> REST .)
    NEQ             reduce using rule 51 (prim -> REST .)
    LT              reduce using rule 51 (prim -> REST .)
    GT              reduce using rule 51 (prim -> REST .)
    LEQ             reduce using rule 51 (prim -> REST .)
    GEQ             reduce using rule 51 (prim -> REST .)
    AND             reduce using rule 51 (prim -> REST .)
    OR              reduce using rule 51 (prim -> REST .)
    PLUS            reduce using rule 51 (prim -> REST .)
    MINUS           reduce using rule 51 (prim -> REST .)
    COMMA           reduce using rule 51 (prim -> REST .)
    $end            reduce using rule 51 (prim -> REST .)
    THEN            reduce using rule 51 (prim -> REST .)
    RP              reduce using rule 51 (prim -> REST .)
    ELSE            reduce using rule 51 (prim -> REST .)
    SC              reduce using rule 51 (prim -> REST .)


state 34

    (52) prim -> ARITY .

    LP              reduce using rule 52 (prim -> ARITY .)
    TIMES           reduce using rule 52 (prim -> ARITY .)
    DIVIDE          reduce using rule 52 (prim -> ARITY .)
    EQ              reduce using rule 52 (prim -> ARITY .)
    NEQ             reduce using rule 52 (prim -> ARITY .)
    LT              reduce using rule 52 (prim -> ARITY .)
    GT              reduce using rule 52 (prim -> ARITY .)
    LEQ             reduce using rule 52 (prim -> ARITY .)
    GEQ             reduce using rule 52 (prim -> ARITY .)
    AND             reduce using rule 52 (prim -> ARITY .)
    OR              reduce using rule 52 (prim -> ARITY .)
    PLUS            reduce using rule 52 (prim -> ARITY .)
    MINUS           reduce using rule 52 (prim -> ARITY .)
    COMMA           reduce using rule 52 (prim -> ARITY .)
    $end            reduce using rule 52 (prim -> ARITY .)
    THEN            reduce using rule 52 (prim -> ARITY .)
    RP              reduce using rule 52 (prim -> ARITY .)
    ELSE            reduce using rule 52 (prim -> ARITY .)
    SC              reduce using rule 52 (prim -> ARITY .)


state 35

    (4) explist -> exp COMMA . explist
    (3) explist -> . exp
    (4) explist -> . exp COMMA explist
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! COMMA           [ reduce using rule 63 (empty -> .) ]
  ! $end            [ reduce using rule 63 (empty -> .) ]
  ! RP              [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    exp                            shift and go to state 4
    explist                        shift and go to state 65
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 36

    (6) exp -> term binop . exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for SC resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)
    THEN            reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)
    ELSE            reduce using rule 53 (id -> .)
    SC              reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! COMMA           [ reduce using rule 63 (empty -> .) ]
  ! $end            [ reduce using rule 63 (empty -> .) ]
  ! THEN            [ reduce using rule 63 (empty -> .) ]
  ! RP              [ reduce using rule 63 (empty -> .) ]
  ! ELSE            [ reduce using rule 63 (empty -> .) ]
  ! SC              [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    term                           shift and go to state 6
    exp                            shift and go to state 66
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 37

    (31) binop -> sign .

    IF              reduce using rule 31 (binop -> sign .)
    LET             reduce using rule 31 (binop -> sign .)
    MAP             reduce using rule 31 (binop -> sign .)
    TILDE           reduce using rule 31 (binop -> sign .)
    LP              reduce using rule 31 (binop -> sign .)
    EMPTY           reduce using rule 31 (binop -> sign .)
    DIGIT           reduce using rule 31 (binop -> sign .)
    CHARACTER       reduce using rule 31 (binop -> sign .)
    TRUE            reduce using rule 31 (binop -> sign .)
    FALSE           reduce using rule 31 (binop -> sign .)
    PLUS            reduce using rule 31 (binop -> sign .)
    MINUS           reduce using rule 31 (binop -> sign .)
    NUMQ            reduce using rule 31 (binop -> sign .)
    FUNQ            reduce using rule 31 (binop -> sign .)
    LISTQ           reduce using rule 31 (binop -> sign .)
    EMPTYQ          reduce using rule 31 (binop -> sign .)
    CONSQ           reduce using rule 31 (binop -> sign .)
    CONS            reduce using rule 31 (binop -> sign .)
    FIRST           reduce using rule 31 (binop -> sign .)
    REST            reduce using rule 31 (binop -> sign .)
    ARITY           reduce using rule 31 (binop -> sign .)
    TIMES           reduce using rule 31 (binop -> sign .)
    DIVIDE          reduce using rule 31 (binop -> sign .)
    EQ              reduce using rule 31 (binop -> sign .)
    NEQ             reduce using rule 31 (binop -> sign .)
    LT              reduce using rule 31 (binop -> sign .)
    GT              reduce using rule 31 (binop -> sign .)
    LEQ             reduce using rule 31 (binop -> sign .)
    GEQ             reduce using rule 31 (binop -> sign .)
    AND             reduce using rule 31 (binop -> sign .)
    OR              reduce using rule 31 (binop -> sign .)
    COMMA           reduce using rule 31 (binop -> sign .)
    $end            reduce using rule 31 (binop -> sign .)
    THEN            reduce using rule 31 (binop -> sign .)
    RP              reduce using rule 31 (binop -> sign .)
    ELSE            reduce using rule 31 (binop -> sign .)
    SC              reduce using rule 31 (binop -> sign .)


state 38

    (32) binop -> TIMES .

    IF              reduce using rule 32 (binop -> TIMES .)
    LET             reduce using rule 32 (binop -> TIMES .)
    MAP             reduce using rule 32 (binop -> TIMES .)
    TILDE           reduce using rule 32 (binop -> TIMES .)
    LP              reduce using rule 32 (binop -> TIMES .)
    EMPTY           reduce using rule 32 (binop -> TIMES .)
    DIGIT           reduce using rule 32 (binop -> TIMES .)
    CHARACTER       reduce using rule 32 (binop -> TIMES .)
    TRUE            reduce using rule 32 (binop -> TIMES .)
    FALSE           reduce using rule 32 (binop -> TIMES .)
    PLUS            reduce using rule 32 (binop -> TIMES .)
    MINUS           reduce using rule 32 (binop -> TIMES .)
    NUMQ            reduce using rule 32 (binop -> TIMES .)
    FUNQ            reduce using rule 32 (binop -> TIMES .)
    LISTQ           reduce using rule 32 (binop -> TIMES .)
    EMPTYQ          reduce using rule 32 (binop -> TIMES .)
    CONSQ           reduce using rule 32 (binop -> TIMES .)
    CONS            reduce using rule 32 (binop -> TIMES .)
    FIRST           reduce using rule 32 (binop -> TIMES .)
    REST            reduce using rule 32 (binop -> TIMES .)
    ARITY           reduce using rule 32 (binop -> TIMES .)
    TIMES           reduce using rule 32 (binop -> TIMES .)
    DIVIDE          reduce using rule 32 (binop -> TIMES .)
    EQ              reduce using rule 32 (binop -> TIMES .)
    NEQ             reduce using rule 32 (binop -> TIMES .)
    LT              reduce using rule 32 (binop -> TIMES .)
    GT              reduce using rule 32 (binop -> TIMES .)
    LEQ             reduce using rule 32 (binop -> TIMES .)
    GEQ             reduce using rule 32 (binop -> TIMES .)
    AND             reduce using rule 32 (binop -> TIMES .)
    OR              reduce using rule 32 (binop -> TIMES .)
    COMMA           reduce using rule 32 (binop -> TIMES .)
    $end            reduce using rule 32 (binop -> TIMES .)
    THEN            reduce using rule 32 (binop -> TIMES .)
    RP              reduce using rule 32 (binop -> TIMES .)
    ELSE            reduce using rule 32 (binop -> TIMES .)
    SC              reduce using rule 32 (binop -> TIMES .)


state 39

    (33) binop -> DIVIDE .

    IF              reduce using rule 33 (binop -> DIVIDE .)
    LET             reduce using rule 33 (binop -> DIVIDE .)
    MAP             reduce using rule 33 (binop -> DIVIDE .)
    TILDE           reduce using rule 33 (binop -> DIVIDE .)
    LP              reduce using rule 33 (binop -> DIVIDE .)
    EMPTY           reduce using rule 33 (binop -> DIVIDE .)
    DIGIT           reduce using rule 33 (binop -> DIVIDE .)
    CHARACTER       reduce using rule 33 (binop -> DIVIDE .)
    TRUE            reduce using rule 33 (binop -> DIVIDE .)
    FALSE           reduce using rule 33 (binop -> DIVIDE .)
    PLUS            reduce using rule 33 (binop -> DIVIDE .)
    MINUS           reduce using rule 33 (binop -> DIVIDE .)
    NUMQ            reduce using rule 33 (binop -> DIVIDE .)
    FUNQ            reduce using rule 33 (binop -> DIVIDE .)
    LISTQ           reduce using rule 33 (binop -> DIVIDE .)
    EMPTYQ          reduce using rule 33 (binop -> DIVIDE .)
    CONSQ           reduce using rule 33 (binop -> DIVIDE .)
    CONS            reduce using rule 33 (binop -> DIVIDE .)
    FIRST           reduce using rule 33 (binop -> DIVIDE .)
    REST            reduce using rule 33 (binop -> DIVIDE .)
    ARITY           reduce using rule 33 (binop -> DIVIDE .)
    TIMES           reduce using rule 33 (binop -> DIVIDE .)
    DIVIDE          reduce using rule 33 (binop -> DIVIDE .)
    EQ              reduce using rule 33 (binop -> DIVIDE .)
    NEQ             reduce using rule 33 (binop -> DIVIDE .)
    LT              reduce using rule 33 (binop -> DIVIDE .)
    GT              reduce using rule 33 (binop -> DIVIDE .)
    LEQ             reduce using rule 33 (binop -> DIVIDE .)
    GEQ             reduce using rule 33 (binop -> DIVIDE .)
    AND             reduce using rule 33 (binop -> DIVIDE .)
    OR              reduce using rule 33 (binop -> DIVIDE .)
    COMMA           reduce using rule 33 (binop -> DIVIDE .)
    $end            reduce using rule 33 (binop -> DIVIDE .)
    THEN            reduce using rule 33 (binop -> DIVIDE .)
    RP              reduce using rule 33 (binop -> DIVIDE .)
    ELSE            reduce using rule 33 (binop -> DIVIDE .)
    SC              reduce using rule 33 (binop -> DIVIDE .)


state 40

    (34) binop -> EQ .

    IF              reduce using rule 34 (binop -> EQ .)
    LET             reduce using rule 34 (binop -> EQ .)
    MAP             reduce using rule 34 (binop -> EQ .)
    TILDE           reduce using rule 34 (binop -> EQ .)
    LP              reduce using rule 34 (binop -> EQ .)
    EMPTY           reduce using rule 34 (binop -> EQ .)
    DIGIT           reduce using rule 34 (binop -> EQ .)
    CHARACTER       reduce using rule 34 (binop -> EQ .)
    TRUE            reduce using rule 34 (binop -> EQ .)
    FALSE           reduce using rule 34 (binop -> EQ .)
    PLUS            reduce using rule 34 (binop -> EQ .)
    MINUS           reduce using rule 34 (binop -> EQ .)
    NUMQ            reduce using rule 34 (binop -> EQ .)
    FUNQ            reduce using rule 34 (binop -> EQ .)
    LISTQ           reduce using rule 34 (binop -> EQ .)
    EMPTYQ          reduce using rule 34 (binop -> EQ .)
    CONSQ           reduce using rule 34 (binop -> EQ .)
    CONS            reduce using rule 34 (binop -> EQ .)
    FIRST           reduce using rule 34 (binop -> EQ .)
    REST            reduce using rule 34 (binop -> EQ .)
    ARITY           reduce using rule 34 (binop -> EQ .)
    TIMES           reduce using rule 34 (binop -> EQ .)
    DIVIDE          reduce using rule 34 (binop -> EQ .)
    EQ              reduce using rule 34 (binop -> EQ .)
    NEQ             reduce using rule 34 (binop -> EQ .)
    LT              reduce using rule 34 (binop -> EQ .)
    GT              reduce using rule 34 (binop -> EQ .)
    LEQ             reduce using rule 34 (binop -> EQ .)
    GEQ             reduce using rule 34 (binop -> EQ .)
    AND             reduce using rule 34 (binop -> EQ .)
    OR              reduce using rule 34 (binop -> EQ .)
    COMMA           reduce using rule 34 (binop -> EQ .)
    $end            reduce using rule 34 (binop -> EQ .)
    THEN            reduce using rule 34 (binop -> EQ .)
    RP              reduce using rule 34 (binop -> EQ .)
    ELSE            reduce using rule 34 (binop -> EQ .)
    SC              reduce using rule 34 (binop -> EQ .)


state 41

    (35) binop -> NEQ .

    IF              reduce using rule 35 (binop -> NEQ .)
    LET             reduce using rule 35 (binop -> NEQ .)
    MAP             reduce using rule 35 (binop -> NEQ .)
    TILDE           reduce using rule 35 (binop -> NEQ .)
    LP              reduce using rule 35 (binop -> NEQ .)
    EMPTY           reduce using rule 35 (binop -> NEQ .)
    DIGIT           reduce using rule 35 (binop -> NEQ .)
    CHARACTER       reduce using rule 35 (binop -> NEQ .)
    TRUE            reduce using rule 35 (binop -> NEQ .)
    FALSE           reduce using rule 35 (binop -> NEQ .)
    PLUS            reduce using rule 35 (binop -> NEQ .)
    MINUS           reduce using rule 35 (binop -> NEQ .)
    NUMQ            reduce using rule 35 (binop -> NEQ .)
    FUNQ            reduce using rule 35 (binop -> NEQ .)
    LISTQ           reduce using rule 35 (binop -> NEQ .)
    EMPTYQ          reduce using rule 35 (binop -> NEQ .)
    CONSQ           reduce using rule 35 (binop -> NEQ .)
    CONS            reduce using rule 35 (binop -> NEQ .)
    FIRST           reduce using rule 35 (binop -> NEQ .)
    REST            reduce using rule 35 (binop -> NEQ .)
    ARITY           reduce using rule 35 (binop -> NEQ .)
    TIMES           reduce using rule 35 (binop -> NEQ .)
    DIVIDE          reduce using rule 35 (binop -> NEQ .)
    EQ              reduce using rule 35 (binop -> NEQ .)
    NEQ             reduce using rule 35 (binop -> NEQ .)
    LT              reduce using rule 35 (binop -> NEQ .)
    GT              reduce using rule 35 (binop -> NEQ .)
    LEQ             reduce using rule 35 (binop -> NEQ .)
    GEQ             reduce using rule 35 (binop -> NEQ .)
    AND             reduce using rule 35 (binop -> NEQ .)
    OR              reduce using rule 35 (binop -> NEQ .)
    COMMA           reduce using rule 35 (binop -> NEQ .)
    $end            reduce using rule 35 (binop -> NEQ .)
    THEN            reduce using rule 35 (binop -> NEQ .)
    RP              reduce using rule 35 (binop -> NEQ .)
    ELSE            reduce using rule 35 (binop -> NEQ .)
    SC              reduce using rule 35 (binop -> NEQ .)


state 42

    (36) binop -> LT .

    IF              reduce using rule 36 (binop -> LT .)
    LET             reduce using rule 36 (binop -> LT .)
    MAP             reduce using rule 36 (binop -> LT .)
    TILDE           reduce using rule 36 (binop -> LT .)
    LP              reduce using rule 36 (binop -> LT .)
    EMPTY           reduce using rule 36 (binop -> LT .)
    DIGIT           reduce using rule 36 (binop -> LT .)
    CHARACTER       reduce using rule 36 (binop -> LT .)
    TRUE            reduce using rule 36 (binop -> LT .)
    FALSE           reduce using rule 36 (binop -> LT .)
    PLUS            reduce using rule 36 (binop -> LT .)
    MINUS           reduce using rule 36 (binop -> LT .)
    NUMQ            reduce using rule 36 (binop -> LT .)
    FUNQ            reduce using rule 36 (binop -> LT .)
    LISTQ           reduce using rule 36 (binop -> LT .)
    EMPTYQ          reduce using rule 36 (binop -> LT .)
    CONSQ           reduce using rule 36 (binop -> LT .)
    CONS            reduce using rule 36 (binop -> LT .)
    FIRST           reduce using rule 36 (binop -> LT .)
    REST            reduce using rule 36 (binop -> LT .)
    ARITY           reduce using rule 36 (binop -> LT .)
    TIMES           reduce using rule 36 (binop -> LT .)
    DIVIDE          reduce using rule 36 (binop -> LT .)
    EQ              reduce using rule 36 (binop -> LT .)
    NEQ             reduce using rule 36 (binop -> LT .)
    LT              reduce using rule 36 (binop -> LT .)
    GT              reduce using rule 36 (binop -> LT .)
    LEQ             reduce using rule 36 (binop -> LT .)
    GEQ             reduce using rule 36 (binop -> LT .)
    AND             reduce using rule 36 (binop -> LT .)
    OR              reduce using rule 36 (binop -> LT .)
    COMMA           reduce using rule 36 (binop -> LT .)
    $end            reduce using rule 36 (binop -> LT .)
    THEN            reduce using rule 36 (binop -> LT .)
    RP              reduce using rule 36 (binop -> LT .)
    ELSE            reduce using rule 36 (binop -> LT .)
    SC              reduce using rule 36 (binop -> LT .)


state 43

    (37) binop -> GT .

    IF              reduce using rule 37 (binop -> GT .)
    LET             reduce using rule 37 (binop -> GT .)
    MAP             reduce using rule 37 (binop -> GT .)
    TILDE           reduce using rule 37 (binop -> GT .)
    LP              reduce using rule 37 (binop -> GT .)
    EMPTY           reduce using rule 37 (binop -> GT .)
    DIGIT           reduce using rule 37 (binop -> GT .)
    CHARACTER       reduce using rule 37 (binop -> GT .)
    TRUE            reduce using rule 37 (binop -> GT .)
    FALSE           reduce using rule 37 (binop -> GT .)
    PLUS            reduce using rule 37 (binop -> GT .)
    MINUS           reduce using rule 37 (binop -> GT .)
    NUMQ            reduce using rule 37 (binop -> GT .)
    FUNQ            reduce using rule 37 (binop -> GT .)
    LISTQ           reduce using rule 37 (binop -> GT .)
    EMPTYQ          reduce using rule 37 (binop -> GT .)
    CONSQ           reduce using rule 37 (binop -> GT .)
    CONS            reduce using rule 37 (binop -> GT .)
    FIRST           reduce using rule 37 (binop -> GT .)
    REST            reduce using rule 37 (binop -> GT .)
    ARITY           reduce using rule 37 (binop -> GT .)
    TIMES           reduce using rule 37 (binop -> GT .)
    DIVIDE          reduce using rule 37 (binop -> GT .)
    EQ              reduce using rule 37 (binop -> GT .)
    NEQ             reduce using rule 37 (binop -> GT .)
    LT              reduce using rule 37 (binop -> GT .)
    GT              reduce using rule 37 (binop -> GT .)
    LEQ             reduce using rule 37 (binop -> GT .)
    GEQ             reduce using rule 37 (binop -> GT .)
    AND             reduce using rule 37 (binop -> GT .)
    OR              reduce using rule 37 (binop -> GT .)
    COMMA           reduce using rule 37 (binop -> GT .)
    $end            reduce using rule 37 (binop -> GT .)
    THEN            reduce using rule 37 (binop -> GT .)
    RP              reduce using rule 37 (binop -> GT .)
    ELSE            reduce using rule 37 (binop -> GT .)
    SC              reduce using rule 37 (binop -> GT .)


state 44

    (38) binop -> LEQ .

    IF              reduce using rule 38 (binop -> LEQ .)
    LET             reduce using rule 38 (binop -> LEQ .)
    MAP             reduce using rule 38 (binop -> LEQ .)
    TILDE           reduce using rule 38 (binop -> LEQ .)
    LP              reduce using rule 38 (binop -> LEQ .)
    EMPTY           reduce using rule 38 (binop -> LEQ .)
    DIGIT           reduce using rule 38 (binop -> LEQ .)
    CHARACTER       reduce using rule 38 (binop -> LEQ .)
    TRUE            reduce using rule 38 (binop -> LEQ .)
    FALSE           reduce using rule 38 (binop -> LEQ .)
    PLUS            reduce using rule 38 (binop -> LEQ .)
    MINUS           reduce using rule 38 (binop -> LEQ .)
    NUMQ            reduce using rule 38 (binop -> LEQ .)
    FUNQ            reduce using rule 38 (binop -> LEQ .)
    LISTQ           reduce using rule 38 (binop -> LEQ .)
    EMPTYQ          reduce using rule 38 (binop -> LEQ .)
    CONSQ           reduce using rule 38 (binop -> LEQ .)
    CONS            reduce using rule 38 (binop -> LEQ .)
    FIRST           reduce using rule 38 (binop -> LEQ .)
    REST            reduce using rule 38 (binop -> LEQ .)
    ARITY           reduce using rule 38 (binop -> LEQ .)
    TIMES           reduce using rule 38 (binop -> LEQ .)
    DIVIDE          reduce using rule 38 (binop -> LEQ .)
    EQ              reduce using rule 38 (binop -> LEQ .)
    NEQ             reduce using rule 38 (binop -> LEQ .)
    LT              reduce using rule 38 (binop -> LEQ .)
    GT              reduce using rule 38 (binop -> LEQ .)
    LEQ             reduce using rule 38 (binop -> LEQ .)
    GEQ             reduce using rule 38 (binop -> LEQ .)
    AND             reduce using rule 38 (binop -> LEQ .)
    OR              reduce using rule 38 (binop -> LEQ .)
    COMMA           reduce using rule 38 (binop -> LEQ .)
    $end            reduce using rule 38 (binop -> LEQ .)
    THEN            reduce using rule 38 (binop -> LEQ .)
    RP              reduce using rule 38 (binop -> LEQ .)
    ELSE            reduce using rule 38 (binop -> LEQ .)
    SC              reduce using rule 38 (binop -> LEQ .)


state 45

    (39) binop -> GEQ .

    IF              reduce using rule 39 (binop -> GEQ .)
    LET             reduce using rule 39 (binop -> GEQ .)
    MAP             reduce using rule 39 (binop -> GEQ .)
    TILDE           reduce using rule 39 (binop -> GEQ .)
    LP              reduce using rule 39 (binop -> GEQ .)
    EMPTY           reduce using rule 39 (binop -> GEQ .)
    DIGIT           reduce using rule 39 (binop -> GEQ .)
    CHARACTER       reduce using rule 39 (binop -> GEQ .)
    TRUE            reduce using rule 39 (binop -> GEQ .)
    FALSE           reduce using rule 39 (binop -> GEQ .)
    PLUS            reduce using rule 39 (binop -> GEQ .)
    MINUS           reduce using rule 39 (binop -> GEQ .)
    NUMQ            reduce using rule 39 (binop -> GEQ .)
    FUNQ            reduce using rule 39 (binop -> GEQ .)
    LISTQ           reduce using rule 39 (binop -> GEQ .)
    EMPTYQ          reduce using rule 39 (binop -> GEQ .)
    CONSQ           reduce using rule 39 (binop -> GEQ .)
    CONS            reduce using rule 39 (binop -> GEQ .)
    FIRST           reduce using rule 39 (binop -> GEQ .)
    REST            reduce using rule 39 (binop -> GEQ .)
    ARITY           reduce using rule 39 (binop -> GEQ .)
    TIMES           reduce using rule 39 (binop -> GEQ .)
    DIVIDE          reduce using rule 39 (binop -> GEQ .)
    EQ              reduce using rule 39 (binop -> GEQ .)
    NEQ             reduce using rule 39 (binop -> GEQ .)
    LT              reduce using rule 39 (binop -> GEQ .)
    GT              reduce using rule 39 (binop -> GEQ .)
    LEQ             reduce using rule 39 (binop -> GEQ .)
    GEQ             reduce using rule 39 (binop -> GEQ .)
    AND             reduce using rule 39 (binop -> GEQ .)
    OR              reduce using rule 39 (binop -> GEQ .)
    COMMA           reduce using rule 39 (binop -> GEQ .)
    $end            reduce using rule 39 (binop -> GEQ .)
    THEN            reduce using rule 39 (binop -> GEQ .)
    RP              reduce using rule 39 (binop -> GEQ .)
    ELSE            reduce using rule 39 (binop -> GEQ .)
    SC              reduce using rule 39 (binop -> GEQ .)


state 46

    (40) binop -> AND .

    IF              reduce using rule 40 (binop -> AND .)
    LET             reduce using rule 40 (binop -> AND .)
    MAP             reduce using rule 40 (binop -> AND .)
    TILDE           reduce using rule 40 (binop -> AND .)
    LP              reduce using rule 40 (binop -> AND .)
    EMPTY           reduce using rule 40 (binop -> AND .)
    DIGIT           reduce using rule 40 (binop -> AND .)
    CHARACTER       reduce using rule 40 (binop -> AND .)
    TRUE            reduce using rule 40 (binop -> AND .)
    FALSE           reduce using rule 40 (binop -> AND .)
    PLUS            reduce using rule 40 (binop -> AND .)
    MINUS           reduce using rule 40 (binop -> AND .)
    NUMQ            reduce using rule 40 (binop -> AND .)
    FUNQ            reduce using rule 40 (binop -> AND .)
    LISTQ           reduce using rule 40 (binop -> AND .)
    EMPTYQ          reduce using rule 40 (binop -> AND .)
    CONSQ           reduce using rule 40 (binop -> AND .)
    CONS            reduce using rule 40 (binop -> AND .)
    FIRST           reduce using rule 40 (binop -> AND .)
    REST            reduce using rule 40 (binop -> AND .)
    ARITY           reduce using rule 40 (binop -> AND .)
    TIMES           reduce using rule 40 (binop -> AND .)
    DIVIDE          reduce using rule 40 (binop -> AND .)
    EQ              reduce using rule 40 (binop -> AND .)
    NEQ             reduce using rule 40 (binop -> AND .)
    LT              reduce using rule 40 (binop -> AND .)
    GT              reduce using rule 40 (binop -> AND .)
    LEQ             reduce using rule 40 (binop -> AND .)
    GEQ             reduce using rule 40 (binop -> AND .)
    AND             reduce using rule 40 (binop -> AND .)
    OR              reduce using rule 40 (binop -> AND .)
    COMMA           reduce using rule 40 (binop -> AND .)
    $end            reduce using rule 40 (binop -> AND .)
    THEN            reduce using rule 40 (binop -> AND .)
    RP              reduce using rule 40 (binop -> AND .)
    ELSE            reduce using rule 40 (binop -> AND .)
    SC              reduce using rule 40 (binop -> AND .)


state 47

    (41) binop -> OR .

    IF              reduce using rule 41 (binop -> OR .)
    LET             reduce using rule 41 (binop -> OR .)
    MAP             reduce using rule 41 (binop -> OR .)
    TILDE           reduce using rule 41 (binop -> OR .)
    LP              reduce using rule 41 (binop -> OR .)
    EMPTY           reduce using rule 41 (binop -> OR .)
    DIGIT           reduce using rule 41 (binop -> OR .)
    CHARACTER       reduce using rule 41 (binop -> OR .)
    TRUE            reduce using rule 41 (binop -> OR .)
    FALSE           reduce using rule 41 (binop -> OR .)
    PLUS            reduce using rule 41 (binop -> OR .)
    MINUS           reduce using rule 41 (binop -> OR .)
    NUMQ            reduce using rule 41 (binop -> OR .)
    FUNQ            reduce using rule 41 (binop -> OR .)
    LISTQ           reduce using rule 41 (binop -> OR .)
    EMPTYQ          reduce using rule 41 (binop -> OR .)
    CONSQ           reduce using rule 41 (binop -> OR .)
    CONS            reduce using rule 41 (binop -> OR .)
    FIRST           reduce using rule 41 (binop -> OR .)
    REST            reduce using rule 41 (binop -> OR .)
    ARITY           reduce using rule 41 (binop -> OR .)
    TIMES           reduce using rule 41 (binop -> OR .)
    DIVIDE          reduce using rule 41 (binop -> OR .)
    EQ              reduce using rule 41 (binop -> OR .)
    NEQ             reduce using rule 41 (binop -> OR .)
    LT              reduce using rule 41 (binop -> OR .)
    GT              reduce using rule 41 (binop -> OR .)
    LEQ             reduce using rule 41 (binop -> OR .)
    GEQ             reduce using rule 41 (binop -> OR .)
    AND             reduce using rule 41 (binop -> OR .)
    OR              reduce using rule 41 (binop -> OR .)
    COMMA           reduce using rule 41 (binop -> OR .)
    $end            reduce using rule 41 (binop -> OR .)
    THEN            reduce using rule 41 (binop -> OR .)
    RP              reduce using rule 41 (binop -> OR .)
    ELSE            reduce using rule 41 (binop -> OR .)
    SC              reduce using rule 41 (binop -> OR .)


state 48

    (7) exp -> IF exp . THEN exp ELSE exp

    THEN            shift and go to state 67


state 49

    (13) term -> empty .

    TIMES           reduce using rule 13 (term -> empty .)
    DIVIDE          reduce using rule 13 (term -> empty .)
    EQ              reduce using rule 13 (term -> empty .)
    NEQ             reduce using rule 13 (term -> empty .)
    LT              reduce using rule 13 (term -> empty .)
    GT              reduce using rule 13 (term -> empty .)
    LEQ             reduce using rule 13 (term -> empty .)
    GEQ             reduce using rule 13 (term -> empty .)
    AND             reduce using rule 13 (term -> empty .)
    OR              reduce using rule 13 (term -> empty .)
    PLUS            reduce using rule 13 (term -> empty .)
    MINUS           reduce using rule 13 (term -> empty .)
    THEN            reduce using rule 13 (term -> empty .)
    COMMA           reduce using rule 13 (term -> empty .)
    $end            reduce using rule 13 (term -> empty .)
    RP              reduce using rule 13 (term -> empty .)
    ELSE            reduce using rule 13 (term -> empty .)
    SC              reduce using rule 13 (term -> empty .)


state 50

    (8) exp -> LET def . IN exp

    IN              shift and go to state 68


state 51

    (21) def -> id . ASSIGN exp SC
    (22) def -> id . ASSIGN exp SC def
    (54) id -> id .

  ! shift/reduce conflict for ASSIGN resolved as shift
    ASSIGN          shift and go to state 69

  ! ASSIGN          [ reduce using rule 54 (id -> id .) ]


state 52

    (55) id -> int .
    (56) id -> int . id
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

  ! reduce/reduce conflict for ASSIGN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for TO resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for SC resolved using rule 53 (id -> .)
    ASSIGN          reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    TO              reduce using rule 53 (id -> .)
    LP              reduce using rule 53 (id -> .)
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    PLUS            reduce using rule 53 (id -> .)
    MINUS           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)
    THEN            reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)
    ELSE            reduce using rule 53 (id -> .)
    SC              reduce using rule 53 (id -> .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

  ! ASSIGN          [ reduce using rule 55 (id -> int .) ]
  ! COMMA           [ reduce using rule 55 (id -> int .) ]
  ! TO              [ reduce using rule 55 (id -> int .) ]
  ! LP              [ reduce using rule 55 (id -> int .) ]
  ! TIMES           [ reduce using rule 55 (id -> int .) ]
  ! DIVIDE          [ reduce using rule 55 (id -> int .) ]
  ! EQ              [ reduce using rule 55 (id -> int .) ]
  ! NEQ             [ reduce using rule 55 (id -> int .) ]
  ! LT              [ reduce using rule 55 (id -> int .) ]
  ! GT              [ reduce using rule 55 (id -> int .) ]
  ! LEQ             [ reduce using rule 55 (id -> int .) ]
  ! GEQ             [ reduce using rule 55 (id -> int .) ]
  ! AND             [ reduce using rule 55 (id -> int .) ]
  ! OR              [ reduce using rule 55 (id -> int .) ]
  ! PLUS            [ reduce using rule 55 (id -> int .) ]
  ! MINUS           [ reduce using rule 55 (id -> int .) ]
  ! $end            [ reduce using rule 55 (id -> int .) ]
  ! THEN            [ reduce using rule 55 (id -> int .) ]
  ! RP              [ reduce using rule 55 (id -> int .) ]
  ! ELSE            [ reduce using rule 55 (id -> int .) ]
  ! SC              [ reduce using rule 55 (id -> int .) ]

    int                            shift and go to state 52
    id                             shift and go to state 61
    string                         shift and go to state 53

state 53

    (57) id -> string .
    (58) id -> string . id
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

  ! reduce/reduce conflict for ASSIGN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for TO resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for SC resolved using rule 53 (id -> .)
    ASSIGN          reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    TO              reduce using rule 53 (id -> .)
    LP              reduce using rule 53 (id -> .)
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    PLUS            reduce using rule 53 (id -> .)
    MINUS           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)
    THEN            reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)
    ELSE            reduce using rule 53 (id -> .)
    SC              reduce using rule 53 (id -> .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

  ! ASSIGN          [ reduce using rule 57 (id -> string .) ]
  ! COMMA           [ reduce using rule 57 (id -> string .) ]
  ! TO              [ reduce using rule 57 (id -> string .) ]
  ! LP              [ reduce using rule 57 (id -> string .) ]
  ! TIMES           [ reduce using rule 57 (id -> string .) ]
  ! DIVIDE          [ reduce using rule 57 (id -> string .) ]
  ! EQ              [ reduce using rule 57 (id -> string .) ]
  ! NEQ             [ reduce using rule 57 (id -> string .) ]
  ! LT              [ reduce using rule 57 (id -> string .) ]
  ! GT              [ reduce using rule 57 (id -> string .) ]
  ! LEQ             [ reduce using rule 57 (id -> string .) ]
  ! GEQ             [ reduce using rule 57 (id -> string .) ]
  ! AND             [ reduce using rule 57 (id -> string .) ]
  ! OR              [ reduce using rule 57 (id -> string .) ]
  ! PLUS            [ reduce using rule 57 (id -> string .) ]
  ! MINUS           [ reduce using rule 57 (id -> string .) ]
  ! $end            [ reduce using rule 57 (id -> string .) ]
  ! THEN            [ reduce using rule 57 (id -> string .) ]
  ! RP              [ reduce using rule 57 (id -> string .) ]
  ! ELSE            [ reduce using rule 57 (id -> string .) ]
  ! SC              [ reduce using rule 57 (id -> string .) ]

    string                         shift and go to state 53
    id                             shift and go to state 62
    int                            shift and go to state 52

state 54

    (9) exp -> MAP idlist . TO exp

    TO              shift and go to state 70


state 55

    (23) idlist -> propidlist .

    TO              reduce using rule 23 (idlist -> propidlist .)


state 56

    (24) idlist -> empty .

    TO              reduce using rule 24 (idlist -> empty .)


state 57

    (25) propidlist -> id .
    (26) propidlist -> id . COMMA propidlist
    (54) id -> id .

  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for TO resolved using rule 25 (propidlist -> id .)
    TO              reduce using rule 25 (propidlist -> id .)
    COMMA           shift and go to state 71

  ! COMMA           [ reduce using rule 54 (id -> id .) ]
  ! TO              [ reduce using rule 54 (id -> id .) ]


state 58

    (10) term -> unop term .

    TIMES           reduce using rule 10 (term -> unop term .)
    DIVIDE          reduce using rule 10 (term -> unop term .)
    EQ              reduce using rule 10 (term -> unop term .)
    NEQ             reduce using rule 10 (term -> unop term .)
    LT              reduce using rule 10 (term -> unop term .)
    GT              reduce using rule 10 (term -> unop term .)
    LEQ             reduce using rule 10 (term -> unop term .)
    GEQ             reduce using rule 10 (term -> unop term .)
    AND             reduce using rule 10 (term -> unop term .)
    OR              reduce using rule 10 (term -> unop term .)
    PLUS            reduce using rule 10 (term -> unop term .)
    MINUS           reduce using rule 10 (term -> unop term .)
    COMMA           reduce using rule 10 (term -> unop term .)
    $end            reduce using rule 10 (term -> unop term .)
    THEN            reduce using rule 10 (term -> unop term .)
    RP              reduce using rule 10 (term -> unop term .)
    ELSE            reduce using rule 10 (term -> unop term .)
    SC              reduce using rule 10 (term -> unop term .)


state 59

    (12) term -> factor LP . mainexplist RP
    (1) mainexplist -> . explist
    (2) mainexplist -> . empty
    (3) explist -> . exp
    (4) explist -> . exp COMMA explist
    (63) empty -> .
    (64) empty -> . EMPTY
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
    EMPTY           shift and go to state 5
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)

  ! RP              [ reduce using rule 63 (empty -> .) ]
  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! COMMA           [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    factor                         shift and go to state 11
    mainexplist                    shift and go to state 72
    explist                        shift and go to state 2
    empty                          shift and go to state 3
    exp                            shift and go to state 4
    term                           shift and go to state 6
    unop                           shift and go to state 10
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 60

    (17) factor -> LP exp . RP

    RP              shift and go to state 73


state 61

    (56) id -> int id .
    (54) id -> id .

  ! reduce/reduce conflict for LP resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for TIMES resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for EQ resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for NEQ resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for LT resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for GT resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for LEQ resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for GEQ resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for AND resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for OR resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for PLUS resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for MINUS resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for COMMA resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for $end resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for THEN resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for RP resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for ELSE resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for SC resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for ASSIGN resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for TO resolved using rule 54 (id -> id .)
    LP              reduce using rule 54 (id -> id .)
    TIMES           reduce using rule 54 (id -> id .)
    DIVIDE          reduce using rule 54 (id -> id .)
    EQ              reduce using rule 54 (id -> id .)
    NEQ             reduce using rule 54 (id -> id .)
    LT              reduce using rule 54 (id -> id .)
    GT              reduce using rule 54 (id -> id .)
    LEQ             reduce using rule 54 (id -> id .)
    GEQ             reduce using rule 54 (id -> id .)
    AND             reduce using rule 54 (id -> id .)
    OR              reduce using rule 54 (id -> id .)
    PLUS            reduce using rule 54 (id -> id .)
    MINUS           reduce using rule 54 (id -> id .)
    COMMA           reduce using rule 54 (id -> id .)
    $end            reduce using rule 54 (id -> id .)
    THEN            reduce using rule 54 (id -> id .)
    RP              reduce using rule 54 (id -> id .)
    ELSE            reduce using rule 54 (id -> id .)
    SC              reduce using rule 54 (id -> id .)
    ASSIGN          reduce using rule 54 (id -> id .)
    TO              reduce using rule 54 (id -> id .)

  ! LP              [ reduce using rule 56 (id -> int id .) ]
  ! TIMES           [ reduce using rule 56 (id -> int id .) ]
  ! DIVIDE          [ reduce using rule 56 (id -> int id .) ]
  ! EQ              [ reduce using rule 56 (id -> int id .) ]
  ! NEQ             [ reduce using rule 56 (id -> int id .) ]
  ! LT              [ reduce using rule 56 (id -> int id .) ]
  ! GT              [ reduce using rule 56 (id -> int id .) ]
  ! LEQ             [ reduce using rule 56 (id -> int id .) ]
  ! GEQ             [ reduce using rule 56 (id -> int id .) ]
  ! AND             [ reduce using rule 56 (id -> int id .) ]
  ! OR              [ reduce using rule 56 (id -> int id .) ]
  ! PLUS            [ reduce using rule 56 (id -> int id .) ]
  ! MINUS           [ reduce using rule 56 (id -> int id .) ]
  ! COMMA           [ reduce using rule 56 (id -> int id .) ]
  ! $end            [ reduce using rule 56 (id -> int id .) ]
  ! THEN            [ reduce using rule 56 (id -> int id .) ]
  ! ASSIGN          [ reduce using rule 56 (id -> int id .) ]
  ! TO              [ reduce using rule 56 (id -> int id .) ]
  ! RP              [ reduce using rule 56 (id -> int id .) ]
  ! ELSE            [ reduce using rule 56 (id -> int id .) ]
  ! SC              [ reduce using rule 56 (id -> int id .) ]


state 62

    (58) id -> string id .
    (54) id -> id .

  ! reduce/reduce conflict for LP resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for TIMES resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for EQ resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for NEQ resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for LT resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for GT resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for LEQ resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for GEQ resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for AND resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for OR resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for PLUS resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for MINUS resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for COMMA resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for $end resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for THEN resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for RP resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for ELSE resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for SC resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for ASSIGN resolved using rule 54 (id -> id .)
  ! reduce/reduce conflict for TO resolved using rule 54 (id -> id .)
    LP              reduce using rule 54 (id -> id .)
    TIMES           reduce using rule 54 (id -> id .)
    DIVIDE          reduce using rule 54 (id -> id .)
    EQ              reduce using rule 54 (id -> id .)
    NEQ             reduce using rule 54 (id -> id .)
    LT              reduce using rule 54 (id -> id .)
    GT              reduce using rule 54 (id -> id .)
    LEQ             reduce using rule 54 (id -> id .)
    GEQ             reduce using rule 54 (id -> id .)
    AND             reduce using rule 54 (id -> id .)
    OR              reduce using rule 54 (id -> id .)
    PLUS            reduce using rule 54 (id -> id .)
    MINUS           reduce using rule 54 (id -> id .)
    COMMA           reduce using rule 54 (id -> id .)
    $end            reduce using rule 54 (id -> id .)
    THEN            reduce using rule 54 (id -> id .)
    RP              reduce using rule 54 (id -> id .)
    ELSE            reduce using rule 54 (id -> id .)
    SC              reduce using rule 54 (id -> id .)
    ASSIGN          reduce using rule 54 (id -> id .)
    TO              reduce using rule 54 (id -> id .)

  ! LP              [ reduce using rule 58 (id -> string id .) ]
  ! TIMES           [ reduce using rule 58 (id -> string id .) ]
  ! DIVIDE          [ reduce using rule 58 (id -> string id .) ]
  ! EQ              [ reduce using rule 58 (id -> string id .) ]
  ! NEQ             [ reduce using rule 58 (id -> string id .) ]
  ! LT              [ reduce using rule 58 (id -> string id .) ]
  ! GT              [ reduce using rule 58 (id -> string id .) ]
  ! LEQ             [ reduce using rule 58 (id -> string id .) ]
  ! GEQ             [ reduce using rule 58 (id -> string id .) ]
  ! AND             [ reduce using rule 58 (id -> string id .) ]
  ! OR              [ reduce using rule 58 (id -> string id .) ]
  ! PLUS            [ reduce using rule 58 (id -> string id .) ]
  ! MINUS           [ reduce using rule 58 (id -> string id .) ]
  ! COMMA           [ reduce using rule 58 (id -> string id .) ]
  ! $end            [ reduce using rule 58 (id -> string id .) ]
  ! THEN            [ reduce using rule 58 (id -> string id .) ]
  ! ASSIGN          [ reduce using rule 58 (id -> string id .) ]
  ! TO              [ reduce using rule 58 (id -> string id .) ]
  ! RP              [ reduce using rule 58 (id -> string id .) ]
  ! ELSE            [ reduce using rule 58 (id -> string id .) ]
  ! SC              [ reduce using rule 58 (id -> string id .) ]


state 63

    (60) int -> DIGIT int .

    DIGIT           reduce using rule 60 (int -> DIGIT int .)
    CHARACTER       reduce using rule 60 (int -> DIGIT int .)
    TIMES           reduce using rule 60 (int -> DIGIT int .)
    DIVIDE          reduce using rule 60 (int -> DIGIT int .)
    EQ              reduce using rule 60 (int -> DIGIT int .)
    NEQ             reduce using rule 60 (int -> DIGIT int .)
    LT              reduce using rule 60 (int -> DIGIT int .)
    GT              reduce using rule 60 (int -> DIGIT int .)
    LEQ             reduce using rule 60 (int -> DIGIT int .)
    GEQ             reduce using rule 60 (int -> DIGIT int .)
    AND             reduce using rule 60 (int -> DIGIT int .)
    OR              reduce using rule 60 (int -> DIGIT int .)
    PLUS            reduce using rule 60 (int -> DIGIT int .)
    MINUS           reduce using rule 60 (int -> DIGIT int .)
    COMMA           reduce using rule 60 (int -> DIGIT int .)
    $end            reduce using rule 60 (int -> DIGIT int .)
    LP              reduce using rule 60 (int -> DIGIT int .)
    THEN            reduce using rule 60 (int -> DIGIT int .)
    ASSIGN          reduce using rule 60 (int -> DIGIT int .)
    TO              reduce using rule 60 (int -> DIGIT int .)
    RP              reduce using rule 60 (int -> DIGIT int .)
    ELSE            reduce using rule 60 (int -> DIGIT int .)
    SC              reduce using rule 60 (int -> DIGIT int .)


state 64

    (62) string -> CHARACTER string .

    DIGIT           reduce using rule 62 (string -> CHARACTER string .)
    CHARACTER       reduce using rule 62 (string -> CHARACTER string .)
    TIMES           reduce using rule 62 (string -> CHARACTER string .)
    DIVIDE          reduce using rule 62 (string -> CHARACTER string .)
    EQ              reduce using rule 62 (string -> CHARACTER string .)
    NEQ             reduce using rule 62 (string -> CHARACTER string .)
    LT              reduce using rule 62 (string -> CHARACTER string .)
    GT              reduce using rule 62 (string -> CHARACTER string .)
    LEQ             reduce using rule 62 (string -> CHARACTER string .)
    GEQ             reduce using rule 62 (string -> CHARACTER string .)
    AND             reduce using rule 62 (string -> CHARACTER string .)
    OR              reduce using rule 62 (string -> CHARACTER string .)
    PLUS            reduce using rule 62 (string -> CHARACTER string .)
    MINUS           reduce using rule 62 (string -> CHARACTER string .)
    COMMA           reduce using rule 62 (string -> CHARACTER string .)
    $end            reduce using rule 62 (string -> CHARACTER string .)
    LP              reduce using rule 62 (string -> CHARACTER string .)
    THEN            reduce using rule 62 (string -> CHARACTER string .)
    ASSIGN          reduce using rule 62 (string -> CHARACTER string .)
    TO              reduce using rule 62 (string -> CHARACTER string .)
    RP              reduce using rule 62 (string -> CHARACTER string .)
    ELSE            reduce using rule 62 (string -> CHARACTER string .)
    SC              reduce using rule 62 (string -> CHARACTER string .)


state 65

    (4) explist -> exp COMMA explist .

    $end            reduce using rule 4 (explist -> exp COMMA explist .)
    RP              reduce using rule 4 (explist -> exp COMMA explist .)


state 66

    (6) exp -> term binop exp .

    COMMA           reduce using rule 6 (exp -> term binop exp .)
    $end            reduce using rule 6 (exp -> term binop exp .)
    THEN            reduce using rule 6 (exp -> term binop exp .)
    RP              reduce using rule 6 (exp -> term binop exp .)
    ELSE            reduce using rule 6 (exp -> term binop exp .)
    SC              reduce using rule 6 (exp -> term binop exp .)


state 67

    (7) exp -> IF exp THEN . exp ELSE exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for ELSE resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    ELSE            reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! ELSE            [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    exp                            shift and go to state 74
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 68

    (8) exp -> LET def IN . exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for SC resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)
    THEN            reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)
    ELSE            reduce using rule 53 (id -> .)
    SC              reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! COMMA           [ reduce using rule 63 (empty -> .) ]
  ! $end            [ reduce using rule 63 (empty -> .) ]
  ! THEN            [ reduce using rule 63 (empty -> .) ]
  ! RP              [ reduce using rule 63 (empty -> .) ]
  ! ELSE            [ reduce using rule 63 (empty -> .) ]
  ! SC              [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    exp                            shift and go to state 75
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 69

    (21) def -> id ASSIGN . exp SC
    (22) def -> id ASSIGN . exp SC def
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for SC resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    SC              reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! SC              [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    id                             shift and go to state 19
    exp                            shift and go to state 76
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18

state 70

    (9) exp -> MAP idlist TO . exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for SC resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)
    THEN            reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)
    ELSE            reduce using rule 53 (id -> .)
    SC              reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! COMMA           [ reduce using rule 63 (empty -> .) ]
  ! $end            [ reduce using rule 63 (empty -> .) ]
  ! THEN            [ reduce using rule 63 (empty -> .) ]
  ! RP              [ reduce using rule 63 (empty -> .) ]
  ! ELSE            [ reduce using rule 63 (empty -> .) ]
  ! SC              [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    exp                            shift and go to state 77
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 71

    (26) propidlist -> id COMMA . propidlist
    (25) propidlist -> . id
    (26) propidlist -> . id COMMA propidlist
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

    COMMA           reduce using rule 53 (id -> .)
    TO              reduce using rule 53 (id -> .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

    id                             shift and go to state 57
    propidlist                     shift and go to state 78
    int                            shift and go to state 52
    string                         shift and go to state 53

state 72

    (12) term -> factor LP mainexplist . RP

    RP              shift and go to state 79


state 73

    (17) factor -> LP exp RP .

    LP              reduce using rule 17 (factor -> LP exp RP .)
    TIMES           reduce using rule 17 (factor -> LP exp RP .)
    DIVIDE          reduce using rule 17 (factor -> LP exp RP .)
    EQ              reduce using rule 17 (factor -> LP exp RP .)
    NEQ             reduce using rule 17 (factor -> LP exp RP .)
    LT              reduce using rule 17 (factor -> LP exp RP .)
    GT              reduce using rule 17 (factor -> LP exp RP .)
    LEQ             reduce using rule 17 (factor -> LP exp RP .)
    GEQ             reduce using rule 17 (factor -> LP exp RP .)
    AND             reduce using rule 17 (factor -> LP exp RP .)
    OR              reduce using rule 17 (factor -> LP exp RP .)
    PLUS            reduce using rule 17 (factor -> LP exp RP .)
    MINUS           reduce using rule 17 (factor -> LP exp RP .)
    COMMA           reduce using rule 17 (factor -> LP exp RP .)
    $end            reduce using rule 17 (factor -> LP exp RP .)
    THEN            reduce using rule 17 (factor -> LP exp RP .)
    RP              reduce using rule 17 (factor -> LP exp RP .)
    ELSE            reduce using rule 17 (factor -> LP exp RP .)
    SC              reduce using rule 17 (factor -> LP exp RP .)


state 74

    (7) exp -> IF exp THEN exp . ELSE exp

    ELSE            shift and go to state 80


state 75

    (8) exp -> LET def IN exp .

    COMMA           reduce using rule 8 (exp -> LET def IN exp .)
    $end            reduce using rule 8 (exp -> LET def IN exp .)
    THEN            reduce using rule 8 (exp -> LET def IN exp .)
    RP              reduce using rule 8 (exp -> LET def IN exp .)
    ELSE            reduce using rule 8 (exp -> LET def IN exp .)
    SC              reduce using rule 8 (exp -> LET def IN exp .)


state 76

    (21) def -> id ASSIGN exp . SC
    (22) def -> id ASSIGN exp . SC def

    SC              shift and go to state 81


state 77

    (9) exp -> MAP idlist TO exp .

    COMMA           reduce using rule 9 (exp -> MAP idlist TO exp .)
    $end            reduce using rule 9 (exp -> MAP idlist TO exp .)
    THEN            reduce using rule 9 (exp -> MAP idlist TO exp .)
    RP              reduce using rule 9 (exp -> MAP idlist TO exp .)
    ELSE            reduce using rule 9 (exp -> MAP idlist TO exp .)
    SC              reduce using rule 9 (exp -> MAP idlist TO exp .)


state 78

    (26) propidlist -> id COMMA propidlist .

    TO              reduce using rule 26 (propidlist -> id COMMA propidlist .)


state 79

    (12) term -> factor LP mainexplist RP .

    TIMES           reduce using rule 12 (term -> factor LP mainexplist RP .)
    DIVIDE          reduce using rule 12 (term -> factor LP mainexplist RP .)
    EQ              reduce using rule 12 (term -> factor LP mainexplist RP .)
    NEQ             reduce using rule 12 (term -> factor LP mainexplist RP .)
    LT              reduce using rule 12 (term -> factor LP mainexplist RP .)
    GT              reduce using rule 12 (term -> factor LP mainexplist RP .)
    LEQ             reduce using rule 12 (term -> factor LP mainexplist RP .)
    GEQ             reduce using rule 12 (term -> factor LP mainexplist RP .)
    AND             reduce using rule 12 (term -> factor LP mainexplist RP .)
    OR              reduce using rule 12 (term -> factor LP mainexplist RP .)
    PLUS            reduce using rule 12 (term -> factor LP mainexplist RP .)
    MINUS           reduce using rule 12 (term -> factor LP mainexplist RP .)
    COMMA           reduce using rule 12 (term -> factor LP mainexplist RP .)
    $end            reduce using rule 12 (term -> factor LP mainexplist RP .)
    THEN            reduce using rule 12 (term -> factor LP mainexplist RP .)
    RP              reduce using rule 12 (term -> factor LP mainexplist RP .)
    ELSE            reduce using rule 12 (term -> factor LP mainexplist RP .)
    SC              reduce using rule 12 (term -> factor LP mainexplist RP .)


state 80

    (7) exp -> IF exp THEN exp ELSE . exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP mainexplist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (29) unop -> . sign
    (30) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (20) factor -> . string
    (63) empty -> .
    (64) empty -> . EMPTY
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string
    (27) bool -> . TRUE
    (28) bool -> . FALSE
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) prim -> . NUMQ
    (45) prim -> . FUNQ
    (46) prim -> . LISTQ
    (47) prim -> . EMPTYQ
    (48) prim -> . CONSQ
    (49) prim -> . CONS
    (50) prim -> . FIRST
    (51) prim -> . REST
    (52) prim -> . ARITY
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GT resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for AND resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for OR resolved using rule 53 (id -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for $end resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for RP resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (id -> .)
  ! reduce/reduce conflict for SC resolved using rule 53 (id -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 53 (id -> .)
    DIVIDE          reduce using rule 53 (id -> .)
    EQ              reduce using rule 53 (id -> .)
    NEQ             reduce using rule 53 (id -> .)
    LT              reduce using rule 53 (id -> .)
    GT              reduce using rule 53 (id -> .)
    LEQ             reduce using rule 53 (id -> .)
    GEQ             reduce using rule 53 (id -> .)
    AND             reduce using rule 53 (id -> .)
    OR              reduce using rule 53 (id -> .)
    COMMA           reduce using rule 53 (id -> .)
    $end            reduce using rule 53 (id -> .)
    THEN            reduce using rule 53 (id -> .)
    RP              reduce using rule 53 (id -> .)
    ELSE            reduce using rule 53 (id -> .)
    SC              reduce using rule 53 (id -> .)

  ! TIMES           [ reduce using rule 63 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 63 (empty -> .) ]
  ! EQ              [ reduce using rule 63 (empty -> .) ]
  ! NEQ             [ reduce using rule 63 (empty -> .) ]
  ! LT              [ reduce using rule 63 (empty -> .) ]
  ! GT              [ reduce using rule 63 (empty -> .) ]
  ! LEQ             [ reduce using rule 63 (empty -> .) ]
  ! GEQ             [ reduce using rule 63 (empty -> .) ]
  ! AND             [ reduce using rule 63 (empty -> .) ]
  ! OR              [ reduce using rule 63 (empty -> .) ]
  ! PLUS            [ reduce using rule 63 (empty -> .) ]
  ! MINUS           [ reduce using rule 63 (empty -> .) ]
  ! COMMA           [ reduce using rule 63 (empty -> .) ]
  ! $end            [ reduce using rule 63 (empty -> .) ]
  ! THEN            [ reduce using rule 63 (empty -> .) ]
  ! RP              [ reduce using rule 63 (empty -> .) ]
  ! ELSE            [ reduce using rule 63 (empty -> .) ]
  ! SC              [ reduce using rule 63 (empty -> .) ]
  ! LP              [ reduce using rule 53 (id -> .) ]
  ! PLUS            [ reduce using rule 53 (id -> .) ]
  ! MINUS           [ reduce using rule 53 (id -> .) ]

    exp                            shift and go to state 82
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 49
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19

state 81

    (21) def -> id ASSIGN exp SC .
    (22) def -> id ASSIGN exp SC . def
    (21) def -> . id ASSIGN exp SC
    (22) def -> . id ASSIGN exp SC def
    (53) id -> .
    (54) id -> . id
    (55) id -> . int
    (56) id -> . int id
    (57) id -> . string
    (58) id -> . string id
    (59) int -> . DIGIT
    (60) int -> . DIGIT int
    (61) string -> . CHARACTER
    (62) string -> . CHARACTER string

    IN              reduce using rule 21 (def -> id ASSIGN exp SC .)
    ASSIGN          reduce using rule 53 (id -> .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

    id                             shift and go to state 51
    def                            shift and go to state 83
    int                            shift and go to state 52
    string                         shift and go to state 53

state 82

    (7) exp -> IF exp THEN exp ELSE exp .

    COMMA           reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    $end            reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    THEN            reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    RP              reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    ELSE            reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    SC              reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)


state 83

    (22) def -> id ASSIGN exp SC def .

    IN              reduce using rule 22 (def -> id ASSIGN exp SC def .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for LP in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for LP in state 7 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 10 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 10 resolved as shift
WARNING: shift/reduce conflict for LP in state 10 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 10 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 10 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 12 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 12 resolved as shift
WARNING: shift/reduce conflict for LP in state 12 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 12 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 12 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 20 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 21 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 35 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 35 resolved as shift
WARNING: shift/reduce conflict for LP in state 35 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 35 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 35 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 36 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 36 resolved as shift
WARNING: shift/reduce conflict for LP in state 36 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 36 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 36 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 51 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 57 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for LP in state 59 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for LP in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for LP in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for LP in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for LP in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for LP in state 80 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (mainexplist -> empty)
WARNING: rejected rule (term -> empty) in state 3
WARNING: reduce/reduce conflict in state 7 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 7
WARNING: reduce/reduce conflict in state 9 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 10
WARNING: reduce/reduce conflict in state 12 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 13 resolved using rule (term -> int)
WARNING: rejected rule (id -> int) in state 13
WARNING: reduce/reduce conflict in state 13 resolved using rule (id -> <empty>)
WARNING: rejected rule (id -> int) in state 13
WARNING: reduce/reduce conflict in state 13 resolved using rule (term -> int)
WARNING: rejected rule (id -> <empty>) in state 13
WARNING: reduce/reduce conflict in state 14 resolved using rule (term -> string)
WARNING: rejected rule (factor -> string) in state 14
WARNING: reduce/reduce conflict in state 14 resolved using rule (factor -> string)
WARNING: rejected rule (id -> string) in state 14
WARNING: reduce/reduce conflict in state 14 resolved using rule (term -> string)
WARNING: rejected rule (id -> string) in state 14
WARNING: reduce/reduce conflict in state 14 resolved using rule (factor -> string)
WARNING: rejected rule (id -> <empty>) in state 14
WARNING: reduce/reduce conflict in state 14 resolved using rule (term -> string)
WARNING: rejected rule (id -> <empty>) in state 14
WARNING: reduce/reduce conflict in state 19 resolved using rule (factor -> id)
WARNING: rejected rule (id -> id) in state 19
WARNING: reduce/reduce conflict in state 35 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 35
WARNING: reduce/reduce conflict in state 36 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 36
WARNING: reduce/reduce conflict in state 52 resolved using rule (id -> <empty>)
WARNING: rejected rule (id -> int) in state 52
WARNING: reduce/reduce conflict in state 53 resolved using rule (id -> <empty>)
WARNING: rejected rule (id -> string) in state 53
WARNING: reduce/reduce conflict in state 57 resolved using rule (propidlist -> id)
WARNING: rejected rule (id -> id) in state 57
WARNING: reduce/reduce conflict in state 59 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 59
WARNING: reduce/reduce conflict in state 61 resolved using rule (id -> id)
WARNING: rejected rule (id -> int id) in state 61
WARNING: reduce/reduce conflict in state 62 resolved using rule (id -> id)
WARNING: rejected rule (id -> string id) in state 62
WARNING: reduce/reduce conflict in state 67 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 67
WARNING: reduce/reduce conflict in state 68 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 68
WARNING: reduce/reduce conflict in state 69 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 69
WARNING: reduce/reduce conflict in state 70 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 70
WARNING: reduce/reduce conflict in state 80 resolved using rule (id -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 80
WARNING: Rule (empty -> <empty>) is never reduced
WARNING: Rule (id -> int) is never reduced
WARNING: Rule (id -> string) is never reduced
WARNING: Rule (id -> int id) is never reduced
WARNING: Rule (id -> string id) is never reduced
