Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CONS
    IN
    LB
    LET
    RB
    TILDE
    TO

Grammar

Rule 0     S' -> explist
Rule 1     explist -> propexplist
Rule 2     propexplist -> exp
Rule 3     propexplist -> exp COMMA propexplist
Rule 4     exp -> term
Rule 5     exp -> term binop exp
Rule 6     exp -> IF exp THEN exp ELSE exp
Rule 7     term -> unop term
Rule 8     term -> factor
Rule 9     term -> factor LP explist RP
Rule 10    term -> int
Rule 11    term -> string
Rule 12    term -> bool
Rule 13    factor -> LP exp RP
Rule 14    factor -> id
Rule 15    def -> id ASSIGN exp
Rule 16    def -> id ASSIGN exp def
Rule 17    propidlist -> id
Rule 18    propidlist -> id COMMA propidlist
Rule 19    bool -> TRUE
Rule 20    bool -> FALSE
Rule 21    unop -> sign
Rule 22    binop -> sign
Rule 23    binop -> TIMES
Rule 24    binop -> DIVIDE
Rule 25    binop -> EQ
Rule 26    binop -> NEQ
Rule 27    binop -> LT
Rule 28    binop -> GT
Rule 29    binop -> LEQ
Rule 30    binop -> GEQ
Rule 31    binop -> AND
Rule 32    binop -> OR
Rule 33    sign -> PLUS
Rule 34    sign -> MINUS
Rule 35    id -> <empty>
Rule 36    id -> int
Rule 37    id -> string
Rule 38    int -> DIGIT
Rule 39    int -> DIGIT int
Rule 40    string -> CHARACTER
Rule 41    string -> CHARACTER string

Terminals, with rules where they appear

AND                  : 31
ASSIGN               : 15 16
CHARACTER            : 40 41
COMMA                : 3 18
CONS                 : 
DIGIT                : 38 39
DIVIDE               : 24
ELSE                 : 6
EQ                   : 25
FALSE                : 20
GEQ                  : 30
GT                   : 28
IF                   : 6
IN                   : 
LB                   : 
LEQ                  : 29
LET                  : 
LP                   : 9 13
LT                   : 27
MINUS                : 34
NEQ                  : 26
OR                   : 32
PLUS                 : 33
RB                   : 
RP                   : 9 13
THEN                 : 6
TILDE                : 
TIMES                : 23
TO                   : 
TRUE                 : 19
error                : 

Nonterminals, with rules where they appear

binop                : 5
bool                 : 12
def                  : 16
exp                  : 2 3 5 6 6 6 13 15 16
explist              : 9 0
factor               : 8 9
id                   : 14 15 16 17 18
int                  : 10 36 39
propexplist          : 1 3
propidlist           : 18
sign                 : 21 22
string               : 11 37 41
term                 : 4 5 7
unop                 : 7

Parsing method: LALR

state 0

    (0) S' -> . explist
    (1) explist -> . propexplist
    (2) propexplist -> . exp
    (3) propexplist -> . exp COMMA propexplist
    (4) exp -> . term
    (5) exp -> . term binop exp
    (6) exp -> . IF exp THEN exp ELSE exp
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 5
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    COMMA           reduce using rule 35 (id -> .)
    $end            reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    explist                        shift and go to state 1
    propexplist                    shift and go to state 2
    exp                            shift and go to state 3
    term                           shift and go to state 4
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 1

    (0) S' -> explist .



state 2

    (1) explist -> propexplist .

    $end            reduce using rule 1 (explist -> propexplist .)
    RP              reduce using rule 1 (explist -> propexplist .)


state 3

    (2) propexplist -> exp .
    (3) propexplist -> exp . COMMA propexplist

    $end            reduce using rule 2 (propexplist -> exp .)
    RP              reduce using rule 2 (propexplist -> exp .)
    COMMA           shift and go to state 20


state 4

    (4) exp -> term .
    (5) exp -> term . binop exp
    (22) binop -> . sign
    (23) binop -> . TIMES
    (24) binop -> . DIVIDE
    (25) binop -> . EQ
    (26) binop -> . NEQ
    (27) binop -> . LT
    (28) binop -> . GT
    (29) binop -> . LEQ
    (30) binop -> . GEQ
    (31) binop -> . AND
    (32) binop -> . OR
    (33) sign -> . PLUS
    (34) sign -> . MINUS

    COMMA           reduce using rule 4 (exp -> term .)
    $end            reduce using rule 4 (exp -> term .)
    THEN            reduce using rule 4 (exp -> term .)
    RP              reduce using rule 4 (exp -> term .)
    ELSE            reduce using rule 4 (exp -> term .)
    TIMES           shift and go to state 23
    DIVIDE          shift and go to state 24
    EQ              shift and go to state 25
    NEQ             shift and go to state 26
    LT              shift and go to state 27
    GT              shift and go to state 28
    LEQ             shift and go to state 29
    GEQ             shift and go to state 30
    AND             shift and go to state 31
    OR              shift and go to state 32
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19

    binop                          shift and go to state 21
    sign                           shift and go to state 22

state 5

    (6) exp -> IF . exp THEN exp ELSE exp
    (4) exp -> . term
    (5) exp -> . term binop exp
    (6) exp -> . IF exp THEN exp ELSE exp
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 5
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    THEN            reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    exp                            shift and go to state 33
    term                           shift and go to state 4
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 6

    (7) term -> unop . term
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    COMMA           reduce using rule 35 (id -> .)
    $end            reduce using rule 35 (id -> .)
    THEN            reduce using rule 35 (id -> .)
    RP              reduce using rule 35 (id -> .)
    ELSE            reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    unop                           shift and go to state 6
    term                           shift and go to state 34
    factor                         shift and go to state 7
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 7

    (8) term -> factor .
    (9) term -> factor . LP explist RP

    TIMES           reduce using rule 8 (term -> factor .)
    DIVIDE          reduce using rule 8 (term -> factor .)
    EQ              reduce using rule 8 (term -> factor .)
    NEQ             reduce using rule 8 (term -> factor .)
    LT              reduce using rule 8 (term -> factor .)
    GT              reduce using rule 8 (term -> factor .)
    LEQ             reduce using rule 8 (term -> factor .)
    GEQ             reduce using rule 8 (term -> factor .)
    AND             reduce using rule 8 (term -> factor .)
    OR              reduce using rule 8 (term -> factor .)
    PLUS            reduce using rule 8 (term -> factor .)
    MINUS           reduce using rule 8 (term -> factor .)
    COMMA           reduce using rule 8 (term -> factor .)
    $end            reduce using rule 8 (term -> factor .)
    THEN            reduce using rule 8 (term -> factor .)
    RP              reduce using rule 8 (term -> factor .)
    ELSE            reduce using rule 8 (term -> factor .)
    LP              shift and go to state 35


state 8

    (13) factor -> LP . exp RP
    (4) exp -> . term
    (5) exp -> . term binop exp
    (6) exp -> . IF exp THEN exp ELSE exp
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 5
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    RP              reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    exp                            shift and go to state 36
    term                           shift and go to state 4
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 9

    (10) term -> int .
    (36) id -> int .

  ! reduce/reduce conflict for TIMES resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for EQ resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for NEQ resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for LT resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for GT resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for LEQ resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for GEQ resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for AND resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for OR resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for PLUS resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for MINUS resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for COMMA resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for $end resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for THEN resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for RP resolved using rule 10 (term -> int .)
  ! reduce/reduce conflict for ELSE resolved using rule 10 (term -> int .)
    TIMES           reduce using rule 10 (term -> int .)
    DIVIDE          reduce using rule 10 (term -> int .)
    EQ              reduce using rule 10 (term -> int .)
    NEQ             reduce using rule 10 (term -> int .)
    LT              reduce using rule 10 (term -> int .)
    GT              reduce using rule 10 (term -> int .)
    LEQ             reduce using rule 10 (term -> int .)
    GEQ             reduce using rule 10 (term -> int .)
    AND             reduce using rule 10 (term -> int .)
    OR              reduce using rule 10 (term -> int .)
    PLUS            reduce using rule 10 (term -> int .)
    MINUS           reduce using rule 10 (term -> int .)
    COMMA           reduce using rule 10 (term -> int .)
    $end            reduce using rule 10 (term -> int .)
    THEN            reduce using rule 10 (term -> int .)
    RP              reduce using rule 10 (term -> int .)
    ELSE            reduce using rule 10 (term -> int .)
    LP              reduce using rule 36 (id -> int .)

  ! TIMES           [ reduce using rule 36 (id -> int .) ]
  ! DIVIDE          [ reduce using rule 36 (id -> int .) ]
  ! EQ              [ reduce using rule 36 (id -> int .) ]
  ! NEQ             [ reduce using rule 36 (id -> int .) ]
  ! LT              [ reduce using rule 36 (id -> int .) ]
  ! GT              [ reduce using rule 36 (id -> int .) ]
  ! LEQ             [ reduce using rule 36 (id -> int .) ]
  ! GEQ             [ reduce using rule 36 (id -> int .) ]
  ! AND             [ reduce using rule 36 (id -> int .) ]
  ! OR              [ reduce using rule 36 (id -> int .) ]
  ! PLUS            [ reduce using rule 36 (id -> int .) ]
  ! MINUS           [ reduce using rule 36 (id -> int .) ]
  ! COMMA           [ reduce using rule 36 (id -> int .) ]
  ! $end            [ reduce using rule 36 (id -> int .) ]
  ! THEN            [ reduce using rule 36 (id -> int .) ]
  ! RP              [ reduce using rule 36 (id -> int .) ]
  ! ELSE            [ reduce using rule 36 (id -> int .) ]


state 10

    (11) term -> string .
    (37) id -> string .

  ! reduce/reduce conflict for TIMES resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for EQ resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for NEQ resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for LT resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for GT resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for LEQ resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for GEQ resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for AND resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for OR resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for PLUS resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for MINUS resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for COMMA resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for $end resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for THEN resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for RP resolved using rule 11 (term -> string .)
  ! reduce/reduce conflict for ELSE resolved using rule 11 (term -> string .)
    TIMES           reduce using rule 11 (term -> string .)
    DIVIDE          reduce using rule 11 (term -> string .)
    EQ              reduce using rule 11 (term -> string .)
    NEQ             reduce using rule 11 (term -> string .)
    LT              reduce using rule 11 (term -> string .)
    GT              reduce using rule 11 (term -> string .)
    LEQ             reduce using rule 11 (term -> string .)
    GEQ             reduce using rule 11 (term -> string .)
    AND             reduce using rule 11 (term -> string .)
    OR              reduce using rule 11 (term -> string .)
    PLUS            reduce using rule 11 (term -> string .)
    MINUS           reduce using rule 11 (term -> string .)
    COMMA           reduce using rule 11 (term -> string .)
    $end            reduce using rule 11 (term -> string .)
    THEN            reduce using rule 11 (term -> string .)
    RP              reduce using rule 11 (term -> string .)
    ELSE            reduce using rule 11 (term -> string .)
    LP              reduce using rule 37 (id -> string .)

  ! TIMES           [ reduce using rule 37 (id -> string .) ]
  ! DIVIDE          [ reduce using rule 37 (id -> string .) ]
  ! EQ              [ reduce using rule 37 (id -> string .) ]
  ! NEQ             [ reduce using rule 37 (id -> string .) ]
  ! LT              [ reduce using rule 37 (id -> string .) ]
  ! GT              [ reduce using rule 37 (id -> string .) ]
  ! LEQ             [ reduce using rule 37 (id -> string .) ]
  ! GEQ             [ reduce using rule 37 (id -> string .) ]
  ! AND             [ reduce using rule 37 (id -> string .) ]
  ! OR              [ reduce using rule 37 (id -> string .) ]
  ! PLUS            [ reduce using rule 37 (id -> string .) ]
  ! MINUS           [ reduce using rule 37 (id -> string .) ]
  ! COMMA           [ reduce using rule 37 (id -> string .) ]
  ! $end            [ reduce using rule 37 (id -> string .) ]
  ! THEN            [ reduce using rule 37 (id -> string .) ]
  ! RP              [ reduce using rule 37 (id -> string .) ]
  ! ELSE            [ reduce using rule 37 (id -> string .) ]


state 11

    (12) term -> bool .

    TIMES           reduce using rule 12 (term -> bool .)
    DIVIDE          reduce using rule 12 (term -> bool .)
    EQ              reduce using rule 12 (term -> bool .)
    NEQ             reduce using rule 12 (term -> bool .)
    LT              reduce using rule 12 (term -> bool .)
    GT              reduce using rule 12 (term -> bool .)
    LEQ             reduce using rule 12 (term -> bool .)
    GEQ             reduce using rule 12 (term -> bool .)
    AND             reduce using rule 12 (term -> bool .)
    OR              reduce using rule 12 (term -> bool .)
    PLUS            reduce using rule 12 (term -> bool .)
    MINUS           reduce using rule 12 (term -> bool .)
    COMMA           reduce using rule 12 (term -> bool .)
    $end            reduce using rule 12 (term -> bool .)
    THEN            reduce using rule 12 (term -> bool .)
    RP              reduce using rule 12 (term -> bool .)
    ELSE            reduce using rule 12 (term -> bool .)


state 12

    (21) unop -> sign .

    LP              reduce using rule 21 (unop -> sign .)
    DIGIT           reduce using rule 21 (unop -> sign .)
    CHARACTER       reduce using rule 21 (unop -> sign .)
    TRUE            reduce using rule 21 (unop -> sign .)
    FALSE           reduce using rule 21 (unop -> sign .)
    PLUS            reduce using rule 21 (unop -> sign .)
    MINUS           reduce using rule 21 (unop -> sign .)
    TIMES           reduce using rule 21 (unop -> sign .)
    DIVIDE          reduce using rule 21 (unop -> sign .)
    EQ              reduce using rule 21 (unop -> sign .)
    NEQ             reduce using rule 21 (unop -> sign .)
    LT              reduce using rule 21 (unop -> sign .)
    GT              reduce using rule 21 (unop -> sign .)
    LEQ             reduce using rule 21 (unop -> sign .)
    GEQ             reduce using rule 21 (unop -> sign .)
    AND             reduce using rule 21 (unop -> sign .)
    OR              reduce using rule 21 (unop -> sign .)
    COMMA           reduce using rule 21 (unop -> sign .)
    $end            reduce using rule 21 (unop -> sign .)
    THEN            reduce using rule 21 (unop -> sign .)
    RP              reduce using rule 21 (unop -> sign .)
    ELSE            reduce using rule 21 (unop -> sign .)


state 13

    (14) factor -> id .

    LP              reduce using rule 14 (factor -> id .)
    TIMES           reduce using rule 14 (factor -> id .)
    DIVIDE          reduce using rule 14 (factor -> id .)
    EQ              reduce using rule 14 (factor -> id .)
    NEQ             reduce using rule 14 (factor -> id .)
    LT              reduce using rule 14 (factor -> id .)
    GT              reduce using rule 14 (factor -> id .)
    LEQ             reduce using rule 14 (factor -> id .)
    GEQ             reduce using rule 14 (factor -> id .)
    AND             reduce using rule 14 (factor -> id .)
    OR              reduce using rule 14 (factor -> id .)
    PLUS            reduce using rule 14 (factor -> id .)
    MINUS           reduce using rule 14 (factor -> id .)
    COMMA           reduce using rule 14 (factor -> id .)
    $end            reduce using rule 14 (factor -> id .)
    THEN            reduce using rule 14 (factor -> id .)
    RP              reduce using rule 14 (factor -> id .)
    ELSE            reduce using rule 14 (factor -> id .)


state 14

    (38) int -> DIGIT .
    (39) int -> DIGIT . int
    (38) int -> . DIGIT
    (39) int -> . DIGIT int

    TIMES           reduce using rule 38 (int -> DIGIT .)
    DIVIDE          reduce using rule 38 (int -> DIGIT .)
    EQ              reduce using rule 38 (int -> DIGIT .)
    NEQ             reduce using rule 38 (int -> DIGIT .)
    LT              reduce using rule 38 (int -> DIGIT .)
    GT              reduce using rule 38 (int -> DIGIT .)
    LEQ             reduce using rule 38 (int -> DIGIT .)
    GEQ             reduce using rule 38 (int -> DIGIT .)
    AND             reduce using rule 38 (int -> DIGIT .)
    OR              reduce using rule 38 (int -> DIGIT .)
    PLUS            reduce using rule 38 (int -> DIGIT .)
    MINUS           reduce using rule 38 (int -> DIGIT .)
    COMMA           reduce using rule 38 (int -> DIGIT .)
    $end            reduce using rule 38 (int -> DIGIT .)
    LP              reduce using rule 38 (int -> DIGIT .)
    THEN            reduce using rule 38 (int -> DIGIT .)
    RP              reduce using rule 38 (int -> DIGIT .)
    ELSE            reduce using rule 38 (int -> DIGIT .)
    DIGIT           shift and go to state 14

    int                            shift and go to state 37

state 15

    (40) string -> CHARACTER .
    (41) string -> CHARACTER . string
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string

    TIMES           reduce using rule 40 (string -> CHARACTER .)
    DIVIDE          reduce using rule 40 (string -> CHARACTER .)
    EQ              reduce using rule 40 (string -> CHARACTER .)
    NEQ             reduce using rule 40 (string -> CHARACTER .)
    LT              reduce using rule 40 (string -> CHARACTER .)
    GT              reduce using rule 40 (string -> CHARACTER .)
    LEQ             reduce using rule 40 (string -> CHARACTER .)
    GEQ             reduce using rule 40 (string -> CHARACTER .)
    AND             reduce using rule 40 (string -> CHARACTER .)
    OR              reduce using rule 40 (string -> CHARACTER .)
    PLUS            reduce using rule 40 (string -> CHARACTER .)
    MINUS           reduce using rule 40 (string -> CHARACTER .)
    COMMA           reduce using rule 40 (string -> CHARACTER .)
    $end            reduce using rule 40 (string -> CHARACTER .)
    LP              reduce using rule 40 (string -> CHARACTER .)
    THEN            reduce using rule 40 (string -> CHARACTER .)
    RP              reduce using rule 40 (string -> CHARACTER .)
    ELSE            reduce using rule 40 (string -> CHARACTER .)
    CHARACTER       shift and go to state 15

    string                         shift and go to state 38

state 16

    (19) bool -> TRUE .

    TIMES           reduce using rule 19 (bool -> TRUE .)
    DIVIDE          reduce using rule 19 (bool -> TRUE .)
    EQ              reduce using rule 19 (bool -> TRUE .)
    NEQ             reduce using rule 19 (bool -> TRUE .)
    LT              reduce using rule 19 (bool -> TRUE .)
    GT              reduce using rule 19 (bool -> TRUE .)
    LEQ             reduce using rule 19 (bool -> TRUE .)
    GEQ             reduce using rule 19 (bool -> TRUE .)
    AND             reduce using rule 19 (bool -> TRUE .)
    OR              reduce using rule 19 (bool -> TRUE .)
    PLUS            reduce using rule 19 (bool -> TRUE .)
    MINUS           reduce using rule 19 (bool -> TRUE .)
    COMMA           reduce using rule 19 (bool -> TRUE .)
    $end            reduce using rule 19 (bool -> TRUE .)
    THEN            reduce using rule 19 (bool -> TRUE .)
    RP              reduce using rule 19 (bool -> TRUE .)
    ELSE            reduce using rule 19 (bool -> TRUE .)


state 17

    (20) bool -> FALSE .

    TIMES           reduce using rule 20 (bool -> FALSE .)
    DIVIDE          reduce using rule 20 (bool -> FALSE .)
    EQ              reduce using rule 20 (bool -> FALSE .)
    NEQ             reduce using rule 20 (bool -> FALSE .)
    LT              reduce using rule 20 (bool -> FALSE .)
    GT              reduce using rule 20 (bool -> FALSE .)
    LEQ             reduce using rule 20 (bool -> FALSE .)
    GEQ             reduce using rule 20 (bool -> FALSE .)
    AND             reduce using rule 20 (bool -> FALSE .)
    OR              reduce using rule 20 (bool -> FALSE .)
    PLUS            reduce using rule 20 (bool -> FALSE .)
    MINUS           reduce using rule 20 (bool -> FALSE .)
    COMMA           reduce using rule 20 (bool -> FALSE .)
    $end            reduce using rule 20 (bool -> FALSE .)
    THEN            reduce using rule 20 (bool -> FALSE .)
    RP              reduce using rule 20 (bool -> FALSE .)
    ELSE            reduce using rule 20 (bool -> FALSE .)


state 18

    (33) sign -> PLUS .

    LP              reduce using rule 33 (sign -> PLUS .)
    DIGIT           reduce using rule 33 (sign -> PLUS .)
    CHARACTER       reduce using rule 33 (sign -> PLUS .)
    TRUE            reduce using rule 33 (sign -> PLUS .)
    FALSE           reduce using rule 33 (sign -> PLUS .)
    PLUS            reduce using rule 33 (sign -> PLUS .)
    MINUS           reduce using rule 33 (sign -> PLUS .)
    TIMES           reduce using rule 33 (sign -> PLUS .)
    DIVIDE          reduce using rule 33 (sign -> PLUS .)
    EQ              reduce using rule 33 (sign -> PLUS .)
    NEQ             reduce using rule 33 (sign -> PLUS .)
    LT              reduce using rule 33 (sign -> PLUS .)
    GT              reduce using rule 33 (sign -> PLUS .)
    LEQ             reduce using rule 33 (sign -> PLUS .)
    GEQ             reduce using rule 33 (sign -> PLUS .)
    AND             reduce using rule 33 (sign -> PLUS .)
    OR              reduce using rule 33 (sign -> PLUS .)
    COMMA           reduce using rule 33 (sign -> PLUS .)
    $end            reduce using rule 33 (sign -> PLUS .)
    IF              reduce using rule 33 (sign -> PLUS .)
    THEN            reduce using rule 33 (sign -> PLUS .)
    RP              reduce using rule 33 (sign -> PLUS .)
    ELSE            reduce using rule 33 (sign -> PLUS .)


state 19

    (34) sign -> MINUS .

    LP              reduce using rule 34 (sign -> MINUS .)
    DIGIT           reduce using rule 34 (sign -> MINUS .)
    CHARACTER       reduce using rule 34 (sign -> MINUS .)
    TRUE            reduce using rule 34 (sign -> MINUS .)
    FALSE           reduce using rule 34 (sign -> MINUS .)
    PLUS            reduce using rule 34 (sign -> MINUS .)
    MINUS           reduce using rule 34 (sign -> MINUS .)
    TIMES           reduce using rule 34 (sign -> MINUS .)
    DIVIDE          reduce using rule 34 (sign -> MINUS .)
    EQ              reduce using rule 34 (sign -> MINUS .)
    NEQ             reduce using rule 34 (sign -> MINUS .)
    LT              reduce using rule 34 (sign -> MINUS .)
    GT              reduce using rule 34 (sign -> MINUS .)
    LEQ             reduce using rule 34 (sign -> MINUS .)
    GEQ             reduce using rule 34 (sign -> MINUS .)
    AND             reduce using rule 34 (sign -> MINUS .)
    OR              reduce using rule 34 (sign -> MINUS .)
    COMMA           reduce using rule 34 (sign -> MINUS .)
    $end            reduce using rule 34 (sign -> MINUS .)
    IF              reduce using rule 34 (sign -> MINUS .)
    THEN            reduce using rule 34 (sign -> MINUS .)
    RP              reduce using rule 34 (sign -> MINUS .)
    ELSE            reduce using rule 34 (sign -> MINUS .)


state 20

    (3) propexplist -> exp COMMA . propexplist
    (2) propexplist -> . exp
    (3) propexplist -> . exp COMMA propexplist
    (4) exp -> . term
    (5) exp -> . term binop exp
    (6) exp -> . IF exp THEN exp ELSE exp
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 5
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    COMMA           reduce using rule 35 (id -> .)
    $end            reduce using rule 35 (id -> .)
    RP              reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    exp                            shift and go to state 3
    propexplist                    shift and go to state 39
    term                           shift and go to state 4
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 21

    (5) exp -> term binop . exp
    (4) exp -> . term
    (5) exp -> . term binop exp
    (6) exp -> . IF exp THEN exp ELSE exp
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 5
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    COMMA           reduce using rule 35 (id -> .)
    $end            reduce using rule 35 (id -> .)
    THEN            reduce using rule 35 (id -> .)
    RP              reduce using rule 35 (id -> .)
    ELSE            reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    term                           shift and go to state 4
    exp                            shift and go to state 40
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 22

    (22) binop -> sign .

    IF              reduce using rule 22 (binop -> sign .)
    LP              reduce using rule 22 (binop -> sign .)
    DIGIT           reduce using rule 22 (binop -> sign .)
    CHARACTER       reduce using rule 22 (binop -> sign .)
    TRUE            reduce using rule 22 (binop -> sign .)
    FALSE           reduce using rule 22 (binop -> sign .)
    PLUS            reduce using rule 22 (binop -> sign .)
    MINUS           reduce using rule 22 (binop -> sign .)
    TIMES           reduce using rule 22 (binop -> sign .)
    DIVIDE          reduce using rule 22 (binop -> sign .)
    EQ              reduce using rule 22 (binop -> sign .)
    NEQ             reduce using rule 22 (binop -> sign .)
    LT              reduce using rule 22 (binop -> sign .)
    GT              reduce using rule 22 (binop -> sign .)
    LEQ             reduce using rule 22 (binop -> sign .)
    GEQ             reduce using rule 22 (binop -> sign .)
    AND             reduce using rule 22 (binop -> sign .)
    OR              reduce using rule 22 (binop -> sign .)
    COMMA           reduce using rule 22 (binop -> sign .)
    $end            reduce using rule 22 (binop -> sign .)
    THEN            reduce using rule 22 (binop -> sign .)
    RP              reduce using rule 22 (binop -> sign .)
    ELSE            reduce using rule 22 (binop -> sign .)


state 23

    (23) binop -> TIMES .

    IF              reduce using rule 23 (binop -> TIMES .)
    LP              reduce using rule 23 (binop -> TIMES .)
    DIGIT           reduce using rule 23 (binop -> TIMES .)
    CHARACTER       reduce using rule 23 (binop -> TIMES .)
    TRUE            reduce using rule 23 (binop -> TIMES .)
    FALSE           reduce using rule 23 (binop -> TIMES .)
    PLUS            reduce using rule 23 (binop -> TIMES .)
    MINUS           reduce using rule 23 (binop -> TIMES .)
    TIMES           reduce using rule 23 (binop -> TIMES .)
    DIVIDE          reduce using rule 23 (binop -> TIMES .)
    EQ              reduce using rule 23 (binop -> TIMES .)
    NEQ             reduce using rule 23 (binop -> TIMES .)
    LT              reduce using rule 23 (binop -> TIMES .)
    GT              reduce using rule 23 (binop -> TIMES .)
    LEQ             reduce using rule 23 (binop -> TIMES .)
    GEQ             reduce using rule 23 (binop -> TIMES .)
    AND             reduce using rule 23 (binop -> TIMES .)
    OR              reduce using rule 23 (binop -> TIMES .)
    COMMA           reduce using rule 23 (binop -> TIMES .)
    $end            reduce using rule 23 (binop -> TIMES .)
    THEN            reduce using rule 23 (binop -> TIMES .)
    RP              reduce using rule 23 (binop -> TIMES .)
    ELSE            reduce using rule 23 (binop -> TIMES .)


state 24

    (24) binop -> DIVIDE .

    IF              reduce using rule 24 (binop -> DIVIDE .)
    LP              reduce using rule 24 (binop -> DIVIDE .)
    DIGIT           reduce using rule 24 (binop -> DIVIDE .)
    CHARACTER       reduce using rule 24 (binop -> DIVIDE .)
    TRUE            reduce using rule 24 (binop -> DIVIDE .)
    FALSE           reduce using rule 24 (binop -> DIVIDE .)
    PLUS            reduce using rule 24 (binop -> DIVIDE .)
    MINUS           reduce using rule 24 (binop -> DIVIDE .)
    TIMES           reduce using rule 24 (binop -> DIVIDE .)
    DIVIDE          reduce using rule 24 (binop -> DIVIDE .)
    EQ              reduce using rule 24 (binop -> DIVIDE .)
    NEQ             reduce using rule 24 (binop -> DIVIDE .)
    LT              reduce using rule 24 (binop -> DIVIDE .)
    GT              reduce using rule 24 (binop -> DIVIDE .)
    LEQ             reduce using rule 24 (binop -> DIVIDE .)
    GEQ             reduce using rule 24 (binop -> DIVIDE .)
    AND             reduce using rule 24 (binop -> DIVIDE .)
    OR              reduce using rule 24 (binop -> DIVIDE .)
    COMMA           reduce using rule 24 (binop -> DIVIDE .)
    $end            reduce using rule 24 (binop -> DIVIDE .)
    THEN            reduce using rule 24 (binop -> DIVIDE .)
    RP              reduce using rule 24 (binop -> DIVIDE .)
    ELSE            reduce using rule 24 (binop -> DIVIDE .)


state 25

    (25) binop -> EQ .

    IF              reduce using rule 25 (binop -> EQ .)
    LP              reduce using rule 25 (binop -> EQ .)
    DIGIT           reduce using rule 25 (binop -> EQ .)
    CHARACTER       reduce using rule 25 (binop -> EQ .)
    TRUE            reduce using rule 25 (binop -> EQ .)
    FALSE           reduce using rule 25 (binop -> EQ .)
    PLUS            reduce using rule 25 (binop -> EQ .)
    MINUS           reduce using rule 25 (binop -> EQ .)
    TIMES           reduce using rule 25 (binop -> EQ .)
    DIVIDE          reduce using rule 25 (binop -> EQ .)
    EQ              reduce using rule 25 (binop -> EQ .)
    NEQ             reduce using rule 25 (binop -> EQ .)
    LT              reduce using rule 25 (binop -> EQ .)
    GT              reduce using rule 25 (binop -> EQ .)
    LEQ             reduce using rule 25 (binop -> EQ .)
    GEQ             reduce using rule 25 (binop -> EQ .)
    AND             reduce using rule 25 (binop -> EQ .)
    OR              reduce using rule 25 (binop -> EQ .)
    COMMA           reduce using rule 25 (binop -> EQ .)
    $end            reduce using rule 25 (binop -> EQ .)
    THEN            reduce using rule 25 (binop -> EQ .)
    RP              reduce using rule 25 (binop -> EQ .)
    ELSE            reduce using rule 25 (binop -> EQ .)


state 26

    (26) binop -> NEQ .

    IF              reduce using rule 26 (binop -> NEQ .)
    LP              reduce using rule 26 (binop -> NEQ .)
    DIGIT           reduce using rule 26 (binop -> NEQ .)
    CHARACTER       reduce using rule 26 (binop -> NEQ .)
    TRUE            reduce using rule 26 (binop -> NEQ .)
    FALSE           reduce using rule 26 (binop -> NEQ .)
    PLUS            reduce using rule 26 (binop -> NEQ .)
    MINUS           reduce using rule 26 (binop -> NEQ .)
    TIMES           reduce using rule 26 (binop -> NEQ .)
    DIVIDE          reduce using rule 26 (binop -> NEQ .)
    EQ              reduce using rule 26 (binop -> NEQ .)
    NEQ             reduce using rule 26 (binop -> NEQ .)
    LT              reduce using rule 26 (binop -> NEQ .)
    GT              reduce using rule 26 (binop -> NEQ .)
    LEQ             reduce using rule 26 (binop -> NEQ .)
    GEQ             reduce using rule 26 (binop -> NEQ .)
    AND             reduce using rule 26 (binop -> NEQ .)
    OR              reduce using rule 26 (binop -> NEQ .)
    COMMA           reduce using rule 26 (binop -> NEQ .)
    $end            reduce using rule 26 (binop -> NEQ .)
    THEN            reduce using rule 26 (binop -> NEQ .)
    RP              reduce using rule 26 (binop -> NEQ .)
    ELSE            reduce using rule 26 (binop -> NEQ .)


state 27

    (27) binop -> LT .

    IF              reduce using rule 27 (binop -> LT .)
    LP              reduce using rule 27 (binop -> LT .)
    DIGIT           reduce using rule 27 (binop -> LT .)
    CHARACTER       reduce using rule 27 (binop -> LT .)
    TRUE            reduce using rule 27 (binop -> LT .)
    FALSE           reduce using rule 27 (binop -> LT .)
    PLUS            reduce using rule 27 (binop -> LT .)
    MINUS           reduce using rule 27 (binop -> LT .)
    TIMES           reduce using rule 27 (binop -> LT .)
    DIVIDE          reduce using rule 27 (binop -> LT .)
    EQ              reduce using rule 27 (binop -> LT .)
    NEQ             reduce using rule 27 (binop -> LT .)
    LT              reduce using rule 27 (binop -> LT .)
    GT              reduce using rule 27 (binop -> LT .)
    LEQ             reduce using rule 27 (binop -> LT .)
    GEQ             reduce using rule 27 (binop -> LT .)
    AND             reduce using rule 27 (binop -> LT .)
    OR              reduce using rule 27 (binop -> LT .)
    COMMA           reduce using rule 27 (binop -> LT .)
    $end            reduce using rule 27 (binop -> LT .)
    THEN            reduce using rule 27 (binop -> LT .)
    RP              reduce using rule 27 (binop -> LT .)
    ELSE            reduce using rule 27 (binop -> LT .)


state 28

    (28) binop -> GT .

    IF              reduce using rule 28 (binop -> GT .)
    LP              reduce using rule 28 (binop -> GT .)
    DIGIT           reduce using rule 28 (binop -> GT .)
    CHARACTER       reduce using rule 28 (binop -> GT .)
    TRUE            reduce using rule 28 (binop -> GT .)
    FALSE           reduce using rule 28 (binop -> GT .)
    PLUS            reduce using rule 28 (binop -> GT .)
    MINUS           reduce using rule 28 (binop -> GT .)
    TIMES           reduce using rule 28 (binop -> GT .)
    DIVIDE          reduce using rule 28 (binop -> GT .)
    EQ              reduce using rule 28 (binop -> GT .)
    NEQ             reduce using rule 28 (binop -> GT .)
    LT              reduce using rule 28 (binop -> GT .)
    GT              reduce using rule 28 (binop -> GT .)
    LEQ             reduce using rule 28 (binop -> GT .)
    GEQ             reduce using rule 28 (binop -> GT .)
    AND             reduce using rule 28 (binop -> GT .)
    OR              reduce using rule 28 (binop -> GT .)
    COMMA           reduce using rule 28 (binop -> GT .)
    $end            reduce using rule 28 (binop -> GT .)
    THEN            reduce using rule 28 (binop -> GT .)
    RP              reduce using rule 28 (binop -> GT .)
    ELSE            reduce using rule 28 (binop -> GT .)


state 29

    (29) binop -> LEQ .

    IF              reduce using rule 29 (binop -> LEQ .)
    LP              reduce using rule 29 (binop -> LEQ .)
    DIGIT           reduce using rule 29 (binop -> LEQ .)
    CHARACTER       reduce using rule 29 (binop -> LEQ .)
    TRUE            reduce using rule 29 (binop -> LEQ .)
    FALSE           reduce using rule 29 (binop -> LEQ .)
    PLUS            reduce using rule 29 (binop -> LEQ .)
    MINUS           reduce using rule 29 (binop -> LEQ .)
    TIMES           reduce using rule 29 (binop -> LEQ .)
    DIVIDE          reduce using rule 29 (binop -> LEQ .)
    EQ              reduce using rule 29 (binop -> LEQ .)
    NEQ             reduce using rule 29 (binop -> LEQ .)
    LT              reduce using rule 29 (binop -> LEQ .)
    GT              reduce using rule 29 (binop -> LEQ .)
    LEQ             reduce using rule 29 (binop -> LEQ .)
    GEQ             reduce using rule 29 (binop -> LEQ .)
    AND             reduce using rule 29 (binop -> LEQ .)
    OR              reduce using rule 29 (binop -> LEQ .)
    COMMA           reduce using rule 29 (binop -> LEQ .)
    $end            reduce using rule 29 (binop -> LEQ .)
    THEN            reduce using rule 29 (binop -> LEQ .)
    RP              reduce using rule 29 (binop -> LEQ .)
    ELSE            reduce using rule 29 (binop -> LEQ .)


state 30

    (30) binop -> GEQ .

    IF              reduce using rule 30 (binop -> GEQ .)
    LP              reduce using rule 30 (binop -> GEQ .)
    DIGIT           reduce using rule 30 (binop -> GEQ .)
    CHARACTER       reduce using rule 30 (binop -> GEQ .)
    TRUE            reduce using rule 30 (binop -> GEQ .)
    FALSE           reduce using rule 30 (binop -> GEQ .)
    PLUS            reduce using rule 30 (binop -> GEQ .)
    MINUS           reduce using rule 30 (binop -> GEQ .)
    TIMES           reduce using rule 30 (binop -> GEQ .)
    DIVIDE          reduce using rule 30 (binop -> GEQ .)
    EQ              reduce using rule 30 (binop -> GEQ .)
    NEQ             reduce using rule 30 (binop -> GEQ .)
    LT              reduce using rule 30 (binop -> GEQ .)
    GT              reduce using rule 30 (binop -> GEQ .)
    LEQ             reduce using rule 30 (binop -> GEQ .)
    GEQ             reduce using rule 30 (binop -> GEQ .)
    AND             reduce using rule 30 (binop -> GEQ .)
    OR              reduce using rule 30 (binop -> GEQ .)
    COMMA           reduce using rule 30 (binop -> GEQ .)
    $end            reduce using rule 30 (binop -> GEQ .)
    THEN            reduce using rule 30 (binop -> GEQ .)
    RP              reduce using rule 30 (binop -> GEQ .)
    ELSE            reduce using rule 30 (binop -> GEQ .)


state 31

    (31) binop -> AND .

    IF              reduce using rule 31 (binop -> AND .)
    LP              reduce using rule 31 (binop -> AND .)
    DIGIT           reduce using rule 31 (binop -> AND .)
    CHARACTER       reduce using rule 31 (binop -> AND .)
    TRUE            reduce using rule 31 (binop -> AND .)
    FALSE           reduce using rule 31 (binop -> AND .)
    PLUS            reduce using rule 31 (binop -> AND .)
    MINUS           reduce using rule 31 (binop -> AND .)
    TIMES           reduce using rule 31 (binop -> AND .)
    DIVIDE          reduce using rule 31 (binop -> AND .)
    EQ              reduce using rule 31 (binop -> AND .)
    NEQ             reduce using rule 31 (binop -> AND .)
    LT              reduce using rule 31 (binop -> AND .)
    GT              reduce using rule 31 (binop -> AND .)
    LEQ             reduce using rule 31 (binop -> AND .)
    GEQ             reduce using rule 31 (binop -> AND .)
    AND             reduce using rule 31 (binop -> AND .)
    OR              reduce using rule 31 (binop -> AND .)
    COMMA           reduce using rule 31 (binop -> AND .)
    $end            reduce using rule 31 (binop -> AND .)
    THEN            reduce using rule 31 (binop -> AND .)
    RP              reduce using rule 31 (binop -> AND .)
    ELSE            reduce using rule 31 (binop -> AND .)


state 32

    (32) binop -> OR .

    IF              reduce using rule 32 (binop -> OR .)
    LP              reduce using rule 32 (binop -> OR .)
    DIGIT           reduce using rule 32 (binop -> OR .)
    CHARACTER       reduce using rule 32 (binop -> OR .)
    TRUE            reduce using rule 32 (binop -> OR .)
    FALSE           reduce using rule 32 (binop -> OR .)
    PLUS            reduce using rule 32 (binop -> OR .)
    MINUS           reduce using rule 32 (binop -> OR .)
    TIMES           reduce using rule 32 (binop -> OR .)
    DIVIDE          reduce using rule 32 (binop -> OR .)
    EQ              reduce using rule 32 (binop -> OR .)
    NEQ             reduce using rule 32 (binop -> OR .)
    LT              reduce using rule 32 (binop -> OR .)
    GT              reduce using rule 32 (binop -> OR .)
    LEQ             reduce using rule 32 (binop -> OR .)
    GEQ             reduce using rule 32 (binop -> OR .)
    AND             reduce using rule 32 (binop -> OR .)
    OR              reduce using rule 32 (binop -> OR .)
    COMMA           reduce using rule 32 (binop -> OR .)
    $end            reduce using rule 32 (binop -> OR .)
    THEN            reduce using rule 32 (binop -> OR .)
    RP              reduce using rule 32 (binop -> OR .)
    ELSE            reduce using rule 32 (binop -> OR .)


state 33

    (6) exp -> IF exp . THEN exp ELSE exp

    THEN            shift and go to state 41


state 34

    (7) term -> unop term .

    TIMES           reduce using rule 7 (term -> unop term .)
    DIVIDE          reduce using rule 7 (term -> unop term .)
    EQ              reduce using rule 7 (term -> unop term .)
    NEQ             reduce using rule 7 (term -> unop term .)
    LT              reduce using rule 7 (term -> unop term .)
    GT              reduce using rule 7 (term -> unop term .)
    LEQ             reduce using rule 7 (term -> unop term .)
    GEQ             reduce using rule 7 (term -> unop term .)
    AND             reduce using rule 7 (term -> unop term .)
    OR              reduce using rule 7 (term -> unop term .)
    PLUS            reduce using rule 7 (term -> unop term .)
    MINUS           reduce using rule 7 (term -> unop term .)
    COMMA           reduce using rule 7 (term -> unop term .)
    $end            reduce using rule 7 (term -> unop term .)
    THEN            reduce using rule 7 (term -> unop term .)
    RP              reduce using rule 7 (term -> unop term .)
    ELSE            reduce using rule 7 (term -> unop term .)


state 35

    (9) term -> factor LP . explist RP
    (1) explist -> . propexplist
    (2) propexplist -> . exp
    (3) propexplist -> . exp COMMA propexplist
    (4) exp -> . term
    (5) exp -> . term binop exp
    (6) exp -> . IF exp THEN exp ELSE exp
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 5
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    COMMA           reduce using rule 35 (id -> .)
    RP              reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    factor                         shift and go to state 7
    explist                        shift and go to state 42
    propexplist                    shift and go to state 2
    exp                            shift and go to state 3
    term                           shift and go to state 4
    unop                           shift and go to state 6
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 36

    (13) factor -> LP exp . RP

    RP              shift and go to state 43


state 37

    (39) int -> DIGIT int .

    TIMES           reduce using rule 39 (int -> DIGIT int .)
    DIVIDE          reduce using rule 39 (int -> DIGIT int .)
    EQ              reduce using rule 39 (int -> DIGIT int .)
    NEQ             reduce using rule 39 (int -> DIGIT int .)
    LT              reduce using rule 39 (int -> DIGIT int .)
    GT              reduce using rule 39 (int -> DIGIT int .)
    LEQ             reduce using rule 39 (int -> DIGIT int .)
    GEQ             reduce using rule 39 (int -> DIGIT int .)
    AND             reduce using rule 39 (int -> DIGIT int .)
    OR              reduce using rule 39 (int -> DIGIT int .)
    PLUS            reduce using rule 39 (int -> DIGIT int .)
    MINUS           reduce using rule 39 (int -> DIGIT int .)
    COMMA           reduce using rule 39 (int -> DIGIT int .)
    $end            reduce using rule 39 (int -> DIGIT int .)
    LP              reduce using rule 39 (int -> DIGIT int .)
    THEN            reduce using rule 39 (int -> DIGIT int .)
    RP              reduce using rule 39 (int -> DIGIT int .)
    ELSE            reduce using rule 39 (int -> DIGIT int .)


state 38

    (41) string -> CHARACTER string .

    TIMES           reduce using rule 41 (string -> CHARACTER string .)
    DIVIDE          reduce using rule 41 (string -> CHARACTER string .)
    EQ              reduce using rule 41 (string -> CHARACTER string .)
    NEQ             reduce using rule 41 (string -> CHARACTER string .)
    LT              reduce using rule 41 (string -> CHARACTER string .)
    GT              reduce using rule 41 (string -> CHARACTER string .)
    LEQ             reduce using rule 41 (string -> CHARACTER string .)
    GEQ             reduce using rule 41 (string -> CHARACTER string .)
    AND             reduce using rule 41 (string -> CHARACTER string .)
    OR              reduce using rule 41 (string -> CHARACTER string .)
    PLUS            reduce using rule 41 (string -> CHARACTER string .)
    MINUS           reduce using rule 41 (string -> CHARACTER string .)
    COMMA           reduce using rule 41 (string -> CHARACTER string .)
    $end            reduce using rule 41 (string -> CHARACTER string .)
    LP              reduce using rule 41 (string -> CHARACTER string .)
    THEN            reduce using rule 41 (string -> CHARACTER string .)
    RP              reduce using rule 41 (string -> CHARACTER string .)
    ELSE            reduce using rule 41 (string -> CHARACTER string .)


state 39

    (3) propexplist -> exp COMMA propexplist .

    $end            reduce using rule 3 (propexplist -> exp COMMA propexplist .)
    RP              reduce using rule 3 (propexplist -> exp COMMA propexplist .)


state 40

    (5) exp -> term binop exp .

    COMMA           reduce using rule 5 (exp -> term binop exp .)
    $end            reduce using rule 5 (exp -> term binop exp .)
    THEN            reduce using rule 5 (exp -> term binop exp .)
    RP              reduce using rule 5 (exp -> term binop exp .)
    ELSE            reduce using rule 5 (exp -> term binop exp .)


state 41

    (6) exp -> IF exp THEN . exp ELSE exp
    (4) exp -> . term
    (5) exp -> . term binop exp
    (6) exp -> . IF exp THEN exp ELSE exp
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 5
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    ELSE            reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    exp                            shift and go to state 44
    term                           shift and go to state 4
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 42

    (9) term -> factor LP explist . RP

    RP              shift and go to state 45


state 43

    (13) factor -> LP exp RP .

    LP              reduce using rule 13 (factor -> LP exp RP .)
    TIMES           reduce using rule 13 (factor -> LP exp RP .)
    DIVIDE          reduce using rule 13 (factor -> LP exp RP .)
    EQ              reduce using rule 13 (factor -> LP exp RP .)
    NEQ             reduce using rule 13 (factor -> LP exp RP .)
    LT              reduce using rule 13 (factor -> LP exp RP .)
    GT              reduce using rule 13 (factor -> LP exp RP .)
    LEQ             reduce using rule 13 (factor -> LP exp RP .)
    GEQ             reduce using rule 13 (factor -> LP exp RP .)
    AND             reduce using rule 13 (factor -> LP exp RP .)
    OR              reduce using rule 13 (factor -> LP exp RP .)
    PLUS            reduce using rule 13 (factor -> LP exp RP .)
    MINUS           reduce using rule 13 (factor -> LP exp RP .)
    COMMA           reduce using rule 13 (factor -> LP exp RP .)
    $end            reduce using rule 13 (factor -> LP exp RP .)
    THEN            reduce using rule 13 (factor -> LP exp RP .)
    RP              reduce using rule 13 (factor -> LP exp RP .)
    ELSE            reduce using rule 13 (factor -> LP exp RP .)


state 44

    (6) exp -> IF exp THEN exp . ELSE exp

    ELSE            shift and go to state 46


state 45

    (9) term -> factor LP explist RP .

    TIMES           reduce using rule 9 (term -> factor LP explist RP .)
    DIVIDE          reduce using rule 9 (term -> factor LP explist RP .)
    EQ              reduce using rule 9 (term -> factor LP explist RP .)
    NEQ             reduce using rule 9 (term -> factor LP explist RP .)
    LT              reduce using rule 9 (term -> factor LP explist RP .)
    GT              reduce using rule 9 (term -> factor LP explist RP .)
    LEQ             reduce using rule 9 (term -> factor LP explist RP .)
    GEQ             reduce using rule 9 (term -> factor LP explist RP .)
    AND             reduce using rule 9 (term -> factor LP explist RP .)
    OR              reduce using rule 9 (term -> factor LP explist RP .)
    PLUS            reduce using rule 9 (term -> factor LP explist RP .)
    MINUS           reduce using rule 9 (term -> factor LP explist RP .)
    COMMA           reduce using rule 9 (term -> factor LP explist RP .)
    $end            reduce using rule 9 (term -> factor LP explist RP .)
    THEN            reduce using rule 9 (term -> factor LP explist RP .)
    RP              reduce using rule 9 (term -> factor LP explist RP .)
    ELSE            reduce using rule 9 (term -> factor LP explist RP .)


state 46

    (6) exp -> IF exp THEN exp ELSE . exp
    (4) exp -> . term
    (5) exp -> . term binop exp
    (6) exp -> . IF exp THEN exp ELSE exp
    (7) term -> . unop term
    (8) term -> . factor
    (9) term -> . factor LP explist RP
    (10) term -> . int
    (11) term -> . string
    (12) term -> . bool
    (21) unop -> . sign
    (13) factor -> . LP exp RP
    (14) factor -> . id
    (38) int -> . DIGIT
    (39) int -> . DIGIT int
    (40) string -> . CHARACTER
    (41) string -> . CHARACTER string
    (19) bool -> . TRUE
    (20) bool -> . FALSE
    (33) sign -> . PLUS
    (34) sign -> . MINUS
    (35) id -> .
    (36) id -> . int
    (37) id -> . string

  ! shift/reduce conflict for LP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 5
    LP              shift and go to state 8
    DIGIT           shift and go to state 14
    CHARACTER       shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           reduce using rule 35 (id -> .)
    DIVIDE          reduce using rule 35 (id -> .)
    EQ              reduce using rule 35 (id -> .)
    NEQ             reduce using rule 35 (id -> .)
    LT              reduce using rule 35 (id -> .)
    GT              reduce using rule 35 (id -> .)
    LEQ             reduce using rule 35 (id -> .)
    GEQ             reduce using rule 35 (id -> .)
    AND             reduce using rule 35 (id -> .)
    OR              reduce using rule 35 (id -> .)
    COMMA           reduce using rule 35 (id -> .)
    $end            reduce using rule 35 (id -> .)
    THEN            reduce using rule 35 (id -> .)
    RP              reduce using rule 35 (id -> .)
    ELSE            reduce using rule 35 (id -> .)

  ! LP              [ reduce using rule 35 (id -> .) ]
  ! PLUS            [ reduce using rule 35 (id -> .) ]
  ! MINUS           [ reduce using rule 35 (id -> .) ]

    exp                            shift and go to state 47
    term                           shift and go to state 4
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    int                            shift and go to state 9
    string                         shift and go to state 10
    bool                           shift and go to state 11
    sign                           shift and go to state 12
    id                             shift and go to state 13

state 47

    (6) exp -> IF exp THEN exp ELSE exp .

    COMMA           reduce using rule 6 (exp -> IF exp THEN exp ELSE exp .)
    $end            reduce using rule 6 (exp -> IF exp THEN exp ELSE exp .)
    THEN            reduce using rule 6 (exp -> IF exp THEN exp ELSE exp .)
    RP              reduce using rule 6 (exp -> IF exp THEN exp ELSE exp .)
    ELSE            reduce using rule 6 (exp -> IF exp THEN exp ELSE exp .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LP in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for LP in state 5 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 5 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 5 resolved as shift
WARNING: shift/reduce conflict for LP in state 6 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 6 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 6 resolved as shift
WARNING: shift/reduce conflict for LP in state 8 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 8 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 8 resolved as shift
WARNING: shift/reduce conflict for LP in state 20 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 20 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 20 resolved as shift
WARNING: shift/reduce conflict for LP in state 21 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 21 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 21 resolved as shift
WARNING: shift/reduce conflict for LP in state 35 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 35 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 35 resolved as shift
WARNING: shift/reduce conflict for LP in state 41 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for LP in state 46 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 46 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 46 resolved as shift
WARNING: reduce/reduce conflict in state 9 resolved using rule (term -> int)
WARNING: rejected rule (id -> int) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (term -> string)
WARNING: rejected rule (id -> string) in state 10
