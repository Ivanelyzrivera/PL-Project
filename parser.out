Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    LB
    RB

Grammar

Rule 0     S' -> explist
Rule 1     explist -> propexplist
Rule 2     explist -> empty
Rule 3     propexplist -> exp
Rule 4     propexplist -> exp COMMA propexplist
Rule 5     exp -> term
Rule 6     exp -> term binop exp
Rule 7     exp -> IF exp THEN exp ELSE exp
Rule 8     exp -> LET def IN exp
Rule 9     exp -> MAP idlist TO exp
Rule 10    term -> unop term
Rule 11    term -> factor
Rule 12    term -> factor LP explist RP
Rule 13    term -> empty
Rule 14    term -> int
Rule 15    term -> string
Rule 16    term -> bool
Rule 17    factor -> LP exp RP
Rule 18    factor -> prim
Rule 19    factor -> id
Rule 20    def -> id ASSIGN exp SC
Rule 21    def -> id ASSIGN exp SC def
Rule 22    idlist -> propidlist
Rule 23    idlist -> empty
Rule 24    propidlist -> id
Rule 25    propidlist -> id COMMA propidlist
Rule 26    bool -> TRUE
Rule 27    bool -> FALSE
Rule 28    unop -> sign
Rule 29    unop -> TILDE
Rule 30    binop -> sign
Rule 31    binop -> TIMES
Rule 32    binop -> DIVIDE
Rule 33    binop -> EQ
Rule 34    binop -> NEQ
Rule 35    binop -> LT
Rule 36    binop -> GT
Rule 37    binop -> LEQ
Rule 38    binop -> GEQ
Rule 39    binop -> AND
Rule 40    binop -> OR
Rule 41    sign -> PLUS
Rule 42    sign -> MINUS
Rule 43    prim -> NUMQ
Rule 44    prim -> FUNQ
Rule 45    prim -> LISTQ
Rule 46    prim -> EMPTYQ
Rule 47    prim -> CONSQ
Rule 48    prim -> CONS
Rule 49    prim -> FIRST
Rule 50    prim -> REST
Rule 51    prim -> ARITY
Rule 52    id -> type
Rule 53    id -> type int
Rule 54    id -> type string
Rule 55    type -> <empty>
Rule 56    type -> NAME
Rule 57    type -> REGION
Rule 58    type -> SERVER
Rule 59    type -> OS
Rule 60    type -> ID
Rule 61    type -> TAG
Rule 62    int -> DIGIT
Rule 63    int -> DIGIT int
Rule 64    string -> CHARACTER
Rule 65    string -> CHARACTER string
Rule 66    empty -> <empty>
Rule 67    empty -> EMPTY

Terminals, with rules where they appear

AND                  : 39
ARITY                : 51
ASSIGN               : 20 21
CHARACTER            : 64 65
COMMA                : 4 25
CONS                 : 48
CONSQ                : 47
DIGIT                : 62 63
DIVIDE               : 32
ELSE                 : 7
EMPTY                : 67
EMPTYQ               : 46
EQ                   : 33
FALSE                : 27
FIRST                : 49
FUNQ                 : 44
GEQ                  : 38
GT                   : 36
ID                   : 60
IF                   : 7
IN                   : 8
LB                   : 
LEQ                  : 37
LET                  : 8
LISTQ                : 45
LP                   : 12 17
LT                   : 35
MAP                  : 9
MINUS                : 42
NAME                 : 56
NEQ                  : 34
NUMQ                 : 43
OR                   : 40
OS                   : 59
PLUS                 : 41
RB                   : 
REGION               : 57
REST                 : 50
RP                   : 12 17
SC                   : 20 21
SERVER               : 58
TAG                  : 61
THEN                 : 7
TILDE                : 29
TIMES                : 31
TO                   : 9
TRUE                 : 26
error                : 

Nonterminals, with rules where they appear

binop                : 6
bool                 : 16
def                  : 8 21
empty                : 2 13 23
exp                  : 3 4 6 7 7 7 8 9 17 20 21
explist              : 12 0
factor               : 11 12
id                   : 19 20 21 24 25
idlist               : 9
int                  : 14 53 63
prim                 : 18
propexplist          : 1 4
propidlist           : 22 25
sign                 : 28 30
string               : 15 54 65
term                 : 5 6 10
type                 : 52 53 54
unop                 : 10

Parsing method: LALR

state 0

    (0) S' -> . explist
    (1) explist -> . propexplist
    (2) explist -> . empty
    (3) propexplist -> . exp
    (4) propexplist -> . exp COMMA propexplist
    (66) empty -> .
    (67) empty -> . EMPTY
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for $end resolved using rule 55 (type -> .)
    EMPTY           shift and go to state 5
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    $end            reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! $end            [ reduce using rule 66 (empty -> .) ]
  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! COMMA           [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    explist                        shift and go to state 1
    propexplist                    shift and go to state 2
    empty                          shift and go to state 3
    exp                            shift and go to state 4
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 1

    (0) S' -> explist .



state 2

    (1) explist -> propexplist .

    $end            reduce using rule 1 (explist -> propexplist .)
    RP              reduce using rule 1 (explist -> propexplist .)


state 3

    (2) explist -> empty .
    (13) term -> empty .

  ! reduce/reduce conflict for $end resolved using rule 2 (explist -> empty .)
  ! reduce/reduce conflict for RP resolved using rule 2 (explist -> empty .)
    $end            reduce using rule 2 (explist -> empty .)
    RP              reduce using rule 2 (explist -> empty .)
    TIMES           reduce using rule 13 (term -> empty .)
    DIVIDE          reduce using rule 13 (term -> empty .)
    EQ              reduce using rule 13 (term -> empty .)
    NEQ             reduce using rule 13 (term -> empty .)
    LT              reduce using rule 13 (term -> empty .)
    GT              reduce using rule 13 (term -> empty .)
    LEQ             reduce using rule 13 (term -> empty .)
    GEQ             reduce using rule 13 (term -> empty .)
    AND             reduce using rule 13 (term -> empty .)
    OR              reduce using rule 13 (term -> empty .)
    PLUS            reduce using rule 13 (term -> empty .)
    MINUS           reduce using rule 13 (term -> empty .)
    COMMA           reduce using rule 13 (term -> empty .)

  ! $end            [ reduce using rule 13 (term -> empty .) ]
  ! RP              [ reduce using rule 13 (term -> empty .) ]


state 4

    (3) propexplist -> exp .
    (4) propexplist -> exp . COMMA propexplist

    $end            reduce using rule 3 (propexplist -> exp .)
    RP              reduce using rule 3 (propexplist -> exp .)
    COMMA           shift and go to state 42


state 5

    (67) empty -> EMPTY .

    $end            reduce using rule 67 (empty -> EMPTY .)
    TIMES           reduce using rule 67 (empty -> EMPTY .)
    DIVIDE          reduce using rule 67 (empty -> EMPTY .)
    EQ              reduce using rule 67 (empty -> EMPTY .)
    NEQ             reduce using rule 67 (empty -> EMPTY .)
    LT              reduce using rule 67 (empty -> EMPTY .)
    GT              reduce using rule 67 (empty -> EMPTY .)
    LEQ             reduce using rule 67 (empty -> EMPTY .)
    GEQ             reduce using rule 67 (empty -> EMPTY .)
    AND             reduce using rule 67 (empty -> EMPTY .)
    OR              reduce using rule 67 (empty -> EMPTY .)
    PLUS            reduce using rule 67 (empty -> EMPTY .)
    MINUS           reduce using rule 67 (empty -> EMPTY .)
    COMMA           reduce using rule 67 (empty -> EMPTY .)
    THEN            reduce using rule 67 (empty -> EMPTY .)
    TO              reduce using rule 67 (empty -> EMPTY .)
    RP              reduce using rule 67 (empty -> EMPTY .)
    ELSE            reduce using rule 67 (empty -> EMPTY .)
    SC              reduce using rule 67 (empty -> EMPTY .)


state 6

    (5) exp -> term .
    (6) exp -> term . binop exp
    (30) binop -> . sign
    (31) binop -> . TIMES
    (32) binop -> . DIVIDE
    (33) binop -> . EQ
    (34) binop -> . NEQ
    (35) binop -> . LT
    (36) binop -> . GT
    (37) binop -> . LEQ
    (38) binop -> . GEQ
    (39) binop -> . AND
    (40) binop -> . OR
    (41) sign -> . PLUS
    (42) sign -> . MINUS

    COMMA           reduce using rule 5 (exp -> term .)
    $end            reduce using rule 5 (exp -> term .)
    THEN            reduce using rule 5 (exp -> term .)
    RP              reduce using rule 5 (exp -> term .)
    ELSE            reduce using rule 5 (exp -> term .)
    SC              reduce using rule 5 (exp -> term .)
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    NEQ             shift and go to state 48
    LT              shift and go to state 49
    GT              shift and go to state 50
    LEQ             shift and go to state 51
    GEQ             shift and go to state 52
    AND             shift and go to state 53
    OR              shift and go to state 54
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25

    binop                          shift and go to state 43
    sign                           shift and go to state 44

state 7

    (7) exp -> IF . exp THEN exp ELSE exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for THEN resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    THEN            reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! THEN            [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    exp                            shift and go to state 55
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 8

    (8) exp -> LET . def IN exp
    (20) def -> . id ASSIGN exp SC
    (21) def -> . id ASSIGN exp SC def
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

    DIGIT           reduce using rule 55 (type -> .)
    CHARACTER       reduce using rule 55 (type -> .)
    ASSIGN          reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

    def                            shift and go to state 57
    id                             shift and go to state 58
    type                           shift and go to state 35

state 9

    (9) exp -> MAP . idlist TO exp
    (22) idlist -> . propidlist
    (23) idlist -> . empty
    (24) propidlist -> . id
    (25) propidlist -> . id COMMA propidlist
    (66) empty -> .
    (67) empty -> . EMPTY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! reduce/reduce conflict for TO resolved using rule 55 (type -> .)
    EMPTY           shift and go to state 5
    DIGIT           reduce using rule 55 (type -> .)
    CHARACTER       reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    TO              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TO              [ reduce using rule 66 (empty -> .) ]

    idlist                         shift and go to state 59
    propidlist                     shift and go to state 60
    empty                          shift and go to state 61
    id                             shift and go to state 62
    type                           shift and go to state 35

state 10

    (10) term -> unop . term
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for $end resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for THEN resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for RP resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for SC resolved using rule 55 (type -> .)
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    $end            reduce using rule 55 (type -> .)
    THEN            reduce using rule 55 (type -> .)
    RP              reduce using rule 55 (type -> .)
    ELSE            reduce using rule 55 (type -> .)
    SC              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! COMMA           [ reduce using rule 66 (empty -> .) ]
  ! $end            [ reduce using rule 66 (empty -> .) ]
  ! THEN            [ reduce using rule 66 (empty -> .) ]
  ! RP              [ reduce using rule 66 (empty -> .) ]
  ! ELSE            [ reduce using rule 66 (empty -> .) ]
  ! SC              [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    unop                           shift and go to state 10
    term                           shift and go to state 63
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 11

    (11) term -> factor .
    (12) term -> factor . LP explist RP

    TIMES           reduce using rule 11 (term -> factor .)
    DIVIDE          reduce using rule 11 (term -> factor .)
    EQ              reduce using rule 11 (term -> factor .)
    NEQ             reduce using rule 11 (term -> factor .)
    LT              reduce using rule 11 (term -> factor .)
    GT              reduce using rule 11 (term -> factor .)
    LEQ             reduce using rule 11 (term -> factor .)
    GEQ             reduce using rule 11 (term -> factor .)
    AND             reduce using rule 11 (term -> factor .)
    OR              reduce using rule 11 (term -> factor .)
    PLUS            reduce using rule 11 (term -> factor .)
    MINUS           reduce using rule 11 (term -> factor .)
    COMMA           reduce using rule 11 (term -> factor .)
    $end            reduce using rule 11 (term -> factor .)
    THEN            reduce using rule 11 (term -> factor .)
    RP              reduce using rule 11 (term -> factor .)
    ELSE            reduce using rule 11 (term -> factor .)
    SC              reduce using rule 11 (term -> factor .)
    LP              shift and go to state 64


state 12

    (17) factor -> LP . exp RP
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for RP resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    RP              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! RP              [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    exp                            shift and go to state 65
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 13

    (14) term -> int .

    TIMES           reduce using rule 14 (term -> int .)
    DIVIDE          reduce using rule 14 (term -> int .)
    EQ              reduce using rule 14 (term -> int .)
    NEQ             reduce using rule 14 (term -> int .)
    LT              reduce using rule 14 (term -> int .)
    GT              reduce using rule 14 (term -> int .)
    LEQ             reduce using rule 14 (term -> int .)
    GEQ             reduce using rule 14 (term -> int .)
    AND             reduce using rule 14 (term -> int .)
    OR              reduce using rule 14 (term -> int .)
    PLUS            reduce using rule 14 (term -> int .)
    MINUS           reduce using rule 14 (term -> int .)
    COMMA           reduce using rule 14 (term -> int .)
    $end            reduce using rule 14 (term -> int .)
    THEN            reduce using rule 14 (term -> int .)
    RP              reduce using rule 14 (term -> int .)
    ELSE            reduce using rule 14 (term -> int .)
    SC              reduce using rule 14 (term -> int .)


state 14

    (15) term -> string .

    TIMES           reduce using rule 15 (term -> string .)
    DIVIDE          reduce using rule 15 (term -> string .)
    EQ              reduce using rule 15 (term -> string .)
    NEQ             reduce using rule 15 (term -> string .)
    LT              reduce using rule 15 (term -> string .)
    GT              reduce using rule 15 (term -> string .)
    LEQ             reduce using rule 15 (term -> string .)
    GEQ             reduce using rule 15 (term -> string .)
    AND             reduce using rule 15 (term -> string .)
    OR              reduce using rule 15 (term -> string .)
    PLUS            reduce using rule 15 (term -> string .)
    MINUS           reduce using rule 15 (term -> string .)
    COMMA           reduce using rule 15 (term -> string .)
    $end            reduce using rule 15 (term -> string .)
    THEN            reduce using rule 15 (term -> string .)
    RP              reduce using rule 15 (term -> string .)
    ELSE            reduce using rule 15 (term -> string .)
    SC              reduce using rule 15 (term -> string .)


state 15

    (16) term -> bool .

    TIMES           reduce using rule 16 (term -> bool .)
    DIVIDE          reduce using rule 16 (term -> bool .)
    EQ              reduce using rule 16 (term -> bool .)
    NEQ             reduce using rule 16 (term -> bool .)
    LT              reduce using rule 16 (term -> bool .)
    GT              reduce using rule 16 (term -> bool .)
    LEQ             reduce using rule 16 (term -> bool .)
    GEQ             reduce using rule 16 (term -> bool .)
    AND             reduce using rule 16 (term -> bool .)
    OR              reduce using rule 16 (term -> bool .)
    PLUS            reduce using rule 16 (term -> bool .)
    MINUS           reduce using rule 16 (term -> bool .)
    COMMA           reduce using rule 16 (term -> bool .)
    $end            reduce using rule 16 (term -> bool .)
    THEN            reduce using rule 16 (term -> bool .)
    RP              reduce using rule 16 (term -> bool .)
    ELSE            reduce using rule 16 (term -> bool .)
    SC              reduce using rule 16 (term -> bool .)


state 16

    (28) unop -> sign .

    TILDE           reduce using rule 28 (unop -> sign .)
    LP              reduce using rule 28 (unop -> sign .)
    EMPTY           reduce using rule 28 (unop -> sign .)
    DIGIT           reduce using rule 28 (unop -> sign .)
    CHARACTER       reduce using rule 28 (unop -> sign .)
    TRUE            reduce using rule 28 (unop -> sign .)
    FALSE           reduce using rule 28 (unop -> sign .)
    PLUS            reduce using rule 28 (unop -> sign .)
    MINUS           reduce using rule 28 (unop -> sign .)
    NUMQ            reduce using rule 28 (unop -> sign .)
    FUNQ            reduce using rule 28 (unop -> sign .)
    LISTQ           reduce using rule 28 (unop -> sign .)
    EMPTYQ          reduce using rule 28 (unop -> sign .)
    CONSQ           reduce using rule 28 (unop -> sign .)
    CONS            reduce using rule 28 (unop -> sign .)
    FIRST           reduce using rule 28 (unop -> sign .)
    REST            reduce using rule 28 (unop -> sign .)
    ARITY           reduce using rule 28 (unop -> sign .)
    NAME            reduce using rule 28 (unop -> sign .)
    REGION          reduce using rule 28 (unop -> sign .)
    SERVER          reduce using rule 28 (unop -> sign .)
    OS              reduce using rule 28 (unop -> sign .)
    ID              reduce using rule 28 (unop -> sign .)
    TAG             reduce using rule 28 (unop -> sign .)
    TIMES           reduce using rule 28 (unop -> sign .)
    DIVIDE          reduce using rule 28 (unop -> sign .)
    EQ              reduce using rule 28 (unop -> sign .)
    NEQ             reduce using rule 28 (unop -> sign .)
    LT              reduce using rule 28 (unop -> sign .)
    GT              reduce using rule 28 (unop -> sign .)
    LEQ             reduce using rule 28 (unop -> sign .)
    GEQ             reduce using rule 28 (unop -> sign .)
    AND             reduce using rule 28 (unop -> sign .)
    OR              reduce using rule 28 (unop -> sign .)
    COMMA           reduce using rule 28 (unop -> sign .)
    $end            reduce using rule 28 (unop -> sign .)
    THEN            reduce using rule 28 (unop -> sign .)
    RP              reduce using rule 28 (unop -> sign .)
    ELSE            reduce using rule 28 (unop -> sign .)
    SC              reduce using rule 28 (unop -> sign .)


state 17

    (29) unop -> TILDE .

    TILDE           reduce using rule 29 (unop -> TILDE .)
    LP              reduce using rule 29 (unop -> TILDE .)
    EMPTY           reduce using rule 29 (unop -> TILDE .)
    DIGIT           reduce using rule 29 (unop -> TILDE .)
    CHARACTER       reduce using rule 29 (unop -> TILDE .)
    TRUE            reduce using rule 29 (unop -> TILDE .)
    FALSE           reduce using rule 29 (unop -> TILDE .)
    PLUS            reduce using rule 29 (unop -> TILDE .)
    MINUS           reduce using rule 29 (unop -> TILDE .)
    NUMQ            reduce using rule 29 (unop -> TILDE .)
    FUNQ            reduce using rule 29 (unop -> TILDE .)
    LISTQ           reduce using rule 29 (unop -> TILDE .)
    EMPTYQ          reduce using rule 29 (unop -> TILDE .)
    CONSQ           reduce using rule 29 (unop -> TILDE .)
    CONS            reduce using rule 29 (unop -> TILDE .)
    FIRST           reduce using rule 29 (unop -> TILDE .)
    REST            reduce using rule 29 (unop -> TILDE .)
    ARITY           reduce using rule 29 (unop -> TILDE .)
    NAME            reduce using rule 29 (unop -> TILDE .)
    REGION          reduce using rule 29 (unop -> TILDE .)
    SERVER          reduce using rule 29 (unop -> TILDE .)
    OS              reduce using rule 29 (unop -> TILDE .)
    ID              reduce using rule 29 (unop -> TILDE .)
    TAG             reduce using rule 29 (unop -> TILDE .)
    TIMES           reduce using rule 29 (unop -> TILDE .)
    DIVIDE          reduce using rule 29 (unop -> TILDE .)
    EQ              reduce using rule 29 (unop -> TILDE .)
    NEQ             reduce using rule 29 (unop -> TILDE .)
    LT              reduce using rule 29 (unop -> TILDE .)
    GT              reduce using rule 29 (unop -> TILDE .)
    LEQ             reduce using rule 29 (unop -> TILDE .)
    GEQ             reduce using rule 29 (unop -> TILDE .)
    AND             reduce using rule 29 (unop -> TILDE .)
    OR              reduce using rule 29 (unop -> TILDE .)
    COMMA           reduce using rule 29 (unop -> TILDE .)
    $end            reduce using rule 29 (unop -> TILDE .)
    THEN            reduce using rule 29 (unop -> TILDE .)
    RP              reduce using rule 29 (unop -> TILDE .)
    ELSE            reduce using rule 29 (unop -> TILDE .)
    SC              reduce using rule 29 (unop -> TILDE .)


state 18

    (18) factor -> prim .

    LP              reduce using rule 18 (factor -> prim .)
    TIMES           reduce using rule 18 (factor -> prim .)
    DIVIDE          reduce using rule 18 (factor -> prim .)
    EQ              reduce using rule 18 (factor -> prim .)
    NEQ             reduce using rule 18 (factor -> prim .)
    LT              reduce using rule 18 (factor -> prim .)
    GT              reduce using rule 18 (factor -> prim .)
    LEQ             reduce using rule 18 (factor -> prim .)
    GEQ             reduce using rule 18 (factor -> prim .)
    AND             reduce using rule 18 (factor -> prim .)
    OR              reduce using rule 18 (factor -> prim .)
    PLUS            reduce using rule 18 (factor -> prim .)
    MINUS           reduce using rule 18 (factor -> prim .)
    COMMA           reduce using rule 18 (factor -> prim .)
    $end            reduce using rule 18 (factor -> prim .)
    THEN            reduce using rule 18 (factor -> prim .)
    RP              reduce using rule 18 (factor -> prim .)
    ELSE            reduce using rule 18 (factor -> prim .)
    SC              reduce using rule 18 (factor -> prim .)


state 19

    (19) factor -> id .

    LP              reduce using rule 19 (factor -> id .)
    TIMES           reduce using rule 19 (factor -> id .)
    DIVIDE          reduce using rule 19 (factor -> id .)
    EQ              reduce using rule 19 (factor -> id .)
    NEQ             reduce using rule 19 (factor -> id .)
    LT              reduce using rule 19 (factor -> id .)
    GT              reduce using rule 19 (factor -> id .)
    LEQ             reduce using rule 19 (factor -> id .)
    GEQ             reduce using rule 19 (factor -> id .)
    AND             reduce using rule 19 (factor -> id .)
    OR              reduce using rule 19 (factor -> id .)
    PLUS            reduce using rule 19 (factor -> id .)
    MINUS           reduce using rule 19 (factor -> id .)
    COMMA           reduce using rule 19 (factor -> id .)
    $end            reduce using rule 19 (factor -> id .)
    THEN            reduce using rule 19 (factor -> id .)
    RP              reduce using rule 19 (factor -> id .)
    ELSE            reduce using rule 19 (factor -> id .)
    SC              reduce using rule 19 (factor -> id .)


state 20

    (62) int -> DIGIT .
    (63) int -> DIGIT . int
    (62) int -> . DIGIT
    (63) int -> . DIGIT int

    TIMES           reduce using rule 62 (int -> DIGIT .)
    DIVIDE          reduce using rule 62 (int -> DIGIT .)
    EQ              reduce using rule 62 (int -> DIGIT .)
    NEQ             reduce using rule 62 (int -> DIGIT .)
    LT              reduce using rule 62 (int -> DIGIT .)
    GT              reduce using rule 62 (int -> DIGIT .)
    LEQ             reduce using rule 62 (int -> DIGIT .)
    GEQ             reduce using rule 62 (int -> DIGIT .)
    AND             reduce using rule 62 (int -> DIGIT .)
    OR              reduce using rule 62 (int -> DIGIT .)
    PLUS            reduce using rule 62 (int -> DIGIT .)
    MINUS           reduce using rule 62 (int -> DIGIT .)
    COMMA           reduce using rule 62 (int -> DIGIT .)
    $end            reduce using rule 62 (int -> DIGIT .)
    THEN            reduce using rule 62 (int -> DIGIT .)
    RP              reduce using rule 62 (int -> DIGIT .)
    ELSE            reduce using rule 62 (int -> DIGIT .)
    SC              reduce using rule 62 (int -> DIGIT .)
    LP              reduce using rule 62 (int -> DIGIT .)
    ASSIGN          reduce using rule 62 (int -> DIGIT .)
    TO              reduce using rule 62 (int -> DIGIT .)
    DIGIT           shift and go to state 20

    int                            shift and go to state 66

state 21

    (64) string -> CHARACTER .
    (65) string -> CHARACTER . string
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string

    TIMES           reduce using rule 64 (string -> CHARACTER .)
    DIVIDE          reduce using rule 64 (string -> CHARACTER .)
    EQ              reduce using rule 64 (string -> CHARACTER .)
    NEQ             reduce using rule 64 (string -> CHARACTER .)
    LT              reduce using rule 64 (string -> CHARACTER .)
    GT              reduce using rule 64 (string -> CHARACTER .)
    LEQ             reduce using rule 64 (string -> CHARACTER .)
    GEQ             reduce using rule 64 (string -> CHARACTER .)
    AND             reduce using rule 64 (string -> CHARACTER .)
    OR              reduce using rule 64 (string -> CHARACTER .)
    PLUS            reduce using rule 64 (string -> CHARACTER .)
    MINUS           reduce using rule 64 (string -> CHARACTER .)
    COMMA           reduce using rule 64 (string -> CHARACTER .)
    $end            reduce using rule 64 (string -> CHARACTER .)
    THEN            reduce using rule 64 (string -> CHARACTER .)
    RP              reduce using rule 64 (string -> CHARACTER .)
    ELSE            reduce using rule 64 (string -> CHARACTER .)
    SC              reduce using rule 64 (string -> CHARACTER .)
    LP              reduce using rule 64 (string -> CHARACTER .)
    ASSIGN          reduce using rule 64 (string -> CHARACTER .)
    TO              reduce using rule 64 (string -> CHARACTER .)
    CHARACTER       shift and go to state 21

    string                         shift and go to state 67

state 22

    (26) bool -> TRUE .

    TIMES           reduce using rule 26 (bool -> TRUE .)
    DIVIDE          reduce using rule 26 (bool -> TRUE .)
    EQ              reduce using rule 26 (bool -> TRUE .)
    NEQ             reduce using rule 26 (bool -> TRUE .)
    LT              reduce using rule 26 (bool -> TRUE .)
    GT              reduce using rule 26 (bool -> TRUE .)
    LEQ             reduce using rule 26 (bool -> TRUE .)
    GEQ             reduce using rule 26 (bool -> TRUE .)
    AND             reduce using rule 26 (bool -> TRUE .)
    OR              reduce using rule 26 (bool -> TRUE .)
    PLUS            reduce using rule 26 (bool -> TRUE .)
    MINUS           reduce using rule 26 (bool -> TRUE .)
    COMMA           reduce using rule 26 (bool -> TRUE .)
    $end            reduce using rule 26 (bool -> TRUE .)
    THEN            reduce using rule 26 (bool -> TRUE .)
    RP              reduce using rule 26 (bool -> TRUE .)
    ELSE            reduce using rule 26 (bool -> TRUE .)
    SC              reduce using rule 26 (bool -> TRUE .)


state 23

    (27) bool -> FALSE .

    TIMES           reduce using rule 27 (bool -> FALSE .)
    DIVIDE          reduce using rule 27 (bool -> FALSE .)
    EQ              reduce using rule 27 (bool -> FALSE .)
    NEQ             reduce using rule 27 (bool -> FALSE .)
    LT              reduce using rule 27 (bool -> FALSE .)
    GT              reduce using rule 27 (bool -> FALSE .)
    LEQ             reduce using rule 27 (bool -> FALSE .)
    GEQ             reduce using rule 27 (bool -> FALSE .)
    AND             reduce using rule 27 (bool -> FALSE .)
    OR              reduce using rule 27 (bool -> FALSE .)
    PLUS            reduce using rule 27 (bool -> FALSE .)
    MINUS           reduce using rule 27 (bool -> FALSE .)
    COMMA           reduce using rule 27 (bool -> FALSE .)
    $end            reduce using rule 27 (bool -> FALSE .)
    THEN            reduce using rule 27 (bool -> FALSE .)
    RP              reduce using rule 27 (bool -> FALSE .)
    ELSE            reduce using rule 27 (bool -> FALSE .)
    SC              reduce using rule 27 (bool -> FALSE .)


state 24

    (41) sign -> PLUS .

    TILDE           reduce using rule 41 (sign -> PLUS .)
    LP              reduce using rule 41 (sign -> PLUS .)
    EMPTY           reduce using rule 41 (sign -> PLUS .)
    DIGIT           reduce using rule 41 (sign -> PLUS .)
    CHARACTER       reduce using rule 41 (sign -> PLUS .)
    TRUE            reduce using rule 41 (sign -> PLUS .)
    FALSE           reduce using rule 41 (sign -> PLUS .)
    PLUS            reduce using rule 41 (sign -> PLUS .)
    MINUS           reduce using rule 41 (sign -> PLUS .)
    NUMQ            reduce using rule 41 (sign -> PLUS .)
    FUNQ            reduce using rule 41 (sign -> PLUS .)
    LISTQ           reduce using rule 41 (sign -> PLUS .)
    EMPTYQ          reduce using rule 41 (sign -> PLUS .)
    CONSQ           reduce using rule 41 (sign -> PLUS .)
    CONS            reduce using rule 41 (sign -> PLUS .)
    FIRST           reduce using rule 41 (sign -> PLUS .)
    REST            reduce using rule 41 (sign -> PLUS .)
    ARITY           reduce using rule 41 (sign -> PLUS .)
    NAME            reduce using rule 41 (sign -> PLUS .)
    REGION          reduce using rule 41 (sign -> PLUS .)
    SERVER          reduce using rule 41 (sign -> PLUS .)
    OS              reduce using rule 41 (sign -> PLUS .)
    ID              reduce using rule 41 (sign -> PLUS .)
    TAG             reduce using rule 41 (sign -> PLUS .)
    TIMES           reduce using rule 41 (sign -> PLUS .)
    DIVIDE          reduce using rule 41 (sign -> PLUS .)
    EQ              reduce using rule 41 (sign -> PLUS .)
    NEQ             reduce using rule 41 (sign -> PLUS .)
    LT              reduce using rule 41 (sign -> PLUS .)
    GT              reduce using rule 41 (sign -> PLUS .)
    LEQ             reduce using rule 41 (sign -> PLUS .)
    GEQ             reduce using rule 41 (sign -> PLUS .)
    AND             reduce using rule 41 (sign -> PLUS .)
    OR              reduce using rule 41 (sign -> PLUS .)
    COMMA           reduce using rule 41 (sign -> PLUS .)
    $end            reduce using rule 41 (sign -> PLUS .)
    IF              reduce using rule 41 (sign -> PLUS .)
    LET             reduce using rule 41 (sign -> PLUS .)
    MAP             reduce using rule 41 (sign -> PLUS .)
    THEN            reduce using rule 41 (sign -> PLUS .)
    RP              reduce using rule 41 (sign -> PLUS .)
    ELSE            reduce using rule 41 (sign -> PLUS .)
    SC              reduce using rule 41 (sign -> PLUS .)


state 25

    (42) sign -> MINUS .

    TILDE           reduce using rule 42 (sign -> MINUS .)
    LP              reduce using rule 42 (sign -> MINUS .)
    EMPTY           reduce using rule 42 (sign -> MINUS .)
    DIGIT           reduce using rule 42 (sign -> MINUS .)
    CHARACTER       reduce using rule 42 (sign -> MINUS .)
    TRUE            reduce using rule 42 (sign -> MINUS .)
    FALSE           reduce using rule 42 (sign -> MINUS .)
    PLUS            reduce using rule 42 (sign -> MINUS .)
    MINUS           reduce using rule 42 (sign -> MINUS .)
    NUMQ            reduce using rule 42 (sign -> MINUS .)
    FUNQ            reduce using rule 42 (sign -> MINUS .)
    LISTQ           reduce using rule 42 (sign -> MINUS .)
    EMPTYQ          reduce using rule 42 (sign -> MINUS .)
    CONSQ           reduce using rule 42 (sign -> MINUS .)
    CONS            reduce using rule 42 (sign -> MINUS .)
    FIRST           reduce using rule 42 (sign -> MINUS .)
    REST            reduce using rule 42 (sign -> MINUS .)
    ARITY           reduce using rule 42 (sign -> MINUS .)
    NAME            reduce using rule 42 (sign -> MINUS .)
    REGION          reduce using rule 42 (sign -> MINUS .)
    SERVER          reduce using rule 42 (sign -> MINUS .)
    OS              reduce using rule 42 (sign -> MINUS .)
    ID              reduce using rule 42 (sign -> MINUS .)
    TAG             reduce using rule 42 (sign -> MINUS .)
    TIMES           reduce using rule 42 (sign -> MINUS .)
    DIVIDE          reduce using rule 42 (sign -> MINUS .)
    EQ              reduce using rule 42 (sign -> MINUS .)
    NEQ             reduce using rule 42 (sign -> MINUS .)
    LT              reduce using rule 42 (sign -> MINUS .)
    GT              reduce using rule 42 (sign -> MINUS .)
    LEQ             reduce using rule 42 (sign -> MINUS .)
    GEQ             reduce using rule 42 (sign -> MINUS .)
    AND             reduce using rule 42 (sign -> MINUS .)
    OR              reduce using rule 42 (sign -> MINUS .)
    COMMA           reduce using rule 42 (sign -> MINUS .)
    $end            reduce using rule 42 (sign -> MINUS .)
    IF              reduce using rule 42 (sign -> MINUS .)
    LET             reduce using rule 42 (sign -> MINUS .)
    MAP             reduce using rule 42 (sign -> MINUS .)
    THEN            reduce using rule 42 (sign -> MINUS .)
    RP              reduce using rule 42 (sign -> MINUS .)
    ELSE            reduce using rule 42 (sign -> MINUS .)
    SC              reduce using rule 42 (sign -> MINUS .)


state 26

    (43) prim -> NUMQ .

    LP              reduce using rule 43 (prim -> NUMQ .)
    TIMES           reduce using rule 43 (prim -> NUMQ .)
    DIVIDE          reduce using rule 43 (prim -> NUMQ .)
    EQ              reduce using rule 43 (prim -> NUMQ .)
    NEQ             reduce using rule 43 (prim -> NUMQ .)
    LT              reduce using rule 43 (prim -> NUMQ .)
    GT              reduce using rule 43 (prim -> NUMQ .)
    LEQ             reduce using rule 43 (prim -> NUMQ .)
    GEQ             reduce using rule 43 (prim -> NUMQ .)
    AND             reduce using rule 43 (prim -> NUMQ .)
    OR              reduce using rule 43 (prim -> NUMQ .)
    PLUS            reduce using rule 43 (prim -> NUMQ .)
    MINUS           reduce using rule 43 (prim -> NUMQ .)
    COMMA           reduce using rule 43 (prim -> NUMQ .)
    $end            reduce using rule 43 (prim -> NUMQ .)
    THEN            reduce using rule 43 (prim -> NUMQ .)
    RP              reduce using rule 43 (prim -> NUMQ .)
    ELSE            reduce using rule 43 (prim -> NUMQ .)
    SC              reduce using rule 43 (prim -> NUMQ .)


state 27

    (44) prim -> FUNQ .

    LP              reduce using rule 44 (prim -> FUNQ .)
    TIMES           reduce using rule 44 (prim -> FUNQ .)
    DIVIDE          reduce using rule 44 (prim -> FUNQ .)
    EQ              reduce using rule 44 (prim -> FUNQ .)
    NEQ             reduce using rule 44 (prim -> FUNQ .)
    LT              reduce using rule 44 (prim -> FUNQ .)
    GT              reduce using rule 44 (prim -> FUNQ .)
    LEQ             reduce using rule 44 (prim -> FUNQ .)
    GEQ             reduce using rule 44 (prim -> FUNQ .)
    AND             reduce using rule 44 (prim -> FUNQ .)
    OR              reduce using rule 44 (prim -> FUNQ .)
    PLUS            reduce using rule 44 (prim -> FUNQ .)
    MINUS           reduce using rule 44 (prim -> FUNQ .)
    COMMA           reduce using rule 44 (prim -> FUNQ .)
    $end            reduce using rule 44 (prim -> FUNQ .)
    THEN            reduce using rule 44 (prim -> FUNQ .)
    RP              reduce using rule 44 (prim -> FUNQ .)
    ELSE            reduce using rule 44 (prim -> FUNQ .)
    SC              reduce using rule 44 (prim -> FUNQ .)


state 28

    (45) prim -> LISTQ .

    LP              reduce using rule 45 (prim -> LISTQ .)
    TIMES           reduce using rule 45 (prim -> LISTQ .)
    DIVIDE          reduce using rule 45 (prim -> LISTQ .)
    EQ              reduce using rule 45 (prim -> LISTQ .)
    NEQ             reduce using rule 45 (prim -> LISTQ .)
    LT              reduce using rule 45 (prim -> LISTQ .)
    GT              reduce using rule 45 (prim -> LISTQ .)
    LEQ             reduce using rule 45 (prim -> LISTQ .)
    GEQ             reduce using rule 45 (prim -> LISTQ .)
    AND             reduce using rule 45 (prim -> LISTQ .)
    OR              reduce using rule 45 (prim -> LISTQ .)
    PLUS            reduce using rule 45 (prim -> LISTQ .)
    MINUS           reduce using rule 45 (prim -> LISTQ .)
    COMMA           reduce using rule 45 (prim -> LISTQ .)
    $end            reduce using rule 45 (prim -> LISTQ .)
    THEN            reduce using rule 45 (prim -> LISTQ .)
    RP              reduce using rule 45 (prim -> LISTQ .)
    ELSE            reduce using rule 45 (prim -> LISTQ .)
    SC              reduce using rule 45 (prim -> LISTQ .)


state 29

    (46) prim -> EMPTYQ .

    LP              reduce using rule 46 (prim -> EMPTYQ .)
    TIMES           reduce using rule 46 (prim -> EMPTYQ .)
    DIVIDE          reduce using rule 46 (prim -> EMPTYQ .)
    EQ              reduce using rule 46 (prim -> EMPTYQ .)
    NEQ             reduce using rule 46 (prim -> EMPTYQ .)
    LT              reduce using rule 46 (prim -> EMPTYQ .)
    GT              reduce using rule 46 (prim -> EMPTYQ .)
    LEQ             reduce using rule 46 (prim -> EMPTYQ .)
    GEQ             reduce using rule 46 (prim -> EMPTYQ .)
    AND             reduce using rule 46 (prim -> EMPTYQ .)
    OR              reduce using rule 46 (prim -> EMPTYQ .)
    PLUS            reduce using rule 46 (prim -> EMPTYQ .)
    MINUS           reduce using rule 46 (prim -> EMPTYQ .)
    COMMA           reduce using rule 46 (prim -> EMPTYQ .)
    $end            reduce using rule 46 (prim -> EMPTYQ .)
    THEN            reduce using rule 46 (prim -> EMPTYQ .)
    RP              reduce using rule 46 (prim -> EMPTYQ .)
    ELSE            reduce using rule 46 (prim -> EMPTYQ .)
    SC              reduce using rule 46 (prim -> EMPTYQ .)


state 30

    (47) prim -> CONSQ .

    LP              reduce using rule 47 (prim -> CONSQ .)
    TIMES           reduce using rule 47 (prim -> CONSQ .)
    DIVIDE          reduce using rule 47 (prim -> CONSQ .)
    EQ              reduce using rule 47 (prim -> CONSQ .)
    NEQ             reduce using rule 47 (prim -> CONSQ .)
    LT              reduce using rule 47 (prim -> CONSQ .)
    GT              reduce using rule 47 (prim -> CONSQ .)
    LEQ             reduce using rule 47 (prim -> CONSQ .)
    GEQ             reduce using rule 47 (prim -> CONSQ .)
    AND             reduce using rule 47 (prim -> CONSQ .)
    OR              reduce using rule 47 (prim -> CONSQ .)
    PLUS            reduce using rule 47 (prim -> CONSQ .)
    MINUS           reduce using rule 47 (prim -> CONSQ .)
    COMMA           reduce using rule 47 (prim -> CONSQ .)
    $end            reduce using rule 47 (prim -> CONSQ .)
    THEN            reduce using rule 47 (prim -> CONSQ .)
    RP              reduce using rule 47 (prim -> CONSQ .)
    ELSE            reduce using rule 47 (prim -> CONSQ .)
    SC              reduce using rule 47 (prim -> CONSQ .)


state 31

    (48) prim -> CONS .

    LP              reduce using rule 48 (prim -> CONS .)
    TIMES           reduce using rule 48 (prim -> CONS .)
    DIVIDE          reduce using rule 48 (prim -> CONS .)
    EQ              reduce using rule 48 (prim -> CONS .)
    NEQ             reduce using rule 48 (prim -> CONS .)
    LT              reduce using rule 48 (prim -> CONS .)
    GT              reduce using rule 48 (prim -> CONS .)
    LEQ             reduce using rule 48 (prim -> CONS .)
    GEQ             reduce using rule 48 (prim -> CONS .)
    AND             reduce using rule 48 (prim -> CONS .)
    OR              reduce using rule 48 (prim -> CONS .)
    PLUS            reduce using rule 48 (prim -> CONS .)
    MINUS           reduce using rule 48 (prim -> CONS .)
    COMMA           reduce using rule 48 (prim -> CONS .)
    $end            reduce using rule 48 (prim -> CONS .)
    THEN            reduce using rule 48 (prim -> CONS .)
    RP              reduce using rule 48 (prim -> CONS .)
    ELSE            reduce using rule 48 (prim -> CONS .)
    SC              reduce using rule 48 (prim -> CONS .)


state 32

    (49) prim -> FIRST .

    LP              reduce using rule 49 (prim -> FIRST .)
    TIMES           reduce using rule 49 (prim -> FIRST .)
    DIVIDE          reduce using rule 49 (prim -> FIRST .)
    EQ              reduce using rule 49 (prim -> FIRST .)
    NEQ             reduce using rule 49 (prim -> FIRST .)
    LT              reduce using rule 49 (prim -> FIRST .)
    GT              reduce using rule 49 (prim -> FIRST .)
    LEQ             reduce using rule 49 (prim -> FIRST .)
    GEQ             reduce using rule 49 (prim -> FIRST .)
    AND             reduce using rule 49 (prim -> FIRST .)
    OR              reduce using rule 49 (prim -> FIRST .)
    PLUS            reduce using rule 49 (prim -> FIRST .)
    MINUS           reduce using rule 49 (prim -> FIRST .)
    COMMA           reduce using rule 49 (prim -> FIRST .)
    $end            reduce using rule 49 (prim -> FIRST .)
    THEN            reduce using rule 49 (prim -> FIRST .)
    RP              reduce using rule 49 (prim -> FIRST .)
    ELSE            reduce using rule 49 (prim -> FIRST .)
    SC              reduce using rule 49 (prim -> FIRST .)


state 33

    (50) prim -> REST .

    LP              reduce using rule 50 (prim -> REST .)
    TIMES           reduce using rule 50 (prim -> REST .)
    DIVIDE          reduce using rule 50 (prim -> REST .)
    EQ              reduce using rule 50 (prim -> REST .)
    NEQ             reduce using rule 50 (prim -> REST .)
    LT              reduce using rule 50 (prim -> REST .)
    GT              reduce using rule 50 (prim -> REST .)
    LEQ             reduce using rule 50 (prim -> REST .)
    GEQ             reduce using rule 50 (prim -> REST .)
    AND             reduce using rule 50 (prim -> REST .)
    OR              reduce using rule 50 (prim -> REST .)
    PLUS            reduce using rule 50 (prim -> REST .)
    MINUS           reduce using rule 50 (prim -> REST .)
    COMMA           reduce using rule 50 (prim -> REST .)
    $end            reduce using rule 50 (prim -> REST .)
    THEN            reduce using rule 50 (prim -> REST .)
    RP              reduce using rule 50 (prim -> REST .)
    ELSE            reduce using rule 50 (prim -> REST .)
    SC              reduce using rule 50 (prim -> REST .)


state 34

    (51) prim -> ARITY .

    LP              reduce using rule 51 (prim -> ARITY .)
    TIMES           reduce using rule 51 (prim -> ARITY .)
    DIVIDE          reduce using rule 51 (prim -> ARITY .)
    EQ              reduce using rule 51 (prim -> ARITY .)
    NEQ             reduce using rule 51 (prim -> ARITY .)
    LT              reduce using rule 51 (prim -> ARITY .)
    GT              reduce using rule 51 (prim -> ARITY .)
    LEQ             reduce using rule 51 (prim -> ARITY .)
    GEQ             reduce using rule 51 (prim -> ARITY .)
    AND             reduce using rule 51 (prim -> ARITY .)
    OR              reduce using rule 51 (prim -> ARITY .)
    PLUS            reduce using rule 51 (prim -> ARITY .)
    MINUS           reduce using rule 51 (prim -> ARITY .)
    COMMA           reduce using rule 51 (prim -> ARITY .)
    $end            reduce using rule 51 (prim -> ARITY .)
    THEN            reduce using rule 51 (prim -> ARITY .)
    RP              reduce using rule 51 (prim -> ARITY .)
    ELSE            reduce using rule 51 (prim -> ARITY .)
    SC              reduce using rule 51 (prim -> ARITY .)


state 35

    (52) id -> type .
    (53) id -> type . int
    (54) id -> type . string
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string

    LP              reduce using rule 52 (id -> type .)
    TIMES           reduce using rule 52 (id -> type .)
    DIVIDE          reduce using rule 52 (id -> type .)
    EQ              reduce using rule 52 (id -> type .)
    NEQ             reduce using rule 52 (id -> type .)
    LT              reduce using rule 52 (id -> type .)
    GT              reduce using rule 52 (id -> type .)
    LEQ             reduce using rule 52 (id -> type .)
    GEQ             reduce using rule 52 (id -> type .)
    AND             reduce using rule 52 (id -> type .)
    OR              reduce using rule 52 (id -> type .)
    PLUS            reduce using rule 52 (id -> type .)
    MINUS           reduce using rule 52 (id -> type .)
    COMMA           reduce using rule 52 (id -> type .)
    $end            reduce using rule 52 (id -> type .)
    THEN            reduce using rule 52 (id -> type .)
    ASSIGN          reduce using rule 52 (id -> type .)
    TO              reduce using rule 52 (id -> type .)
    RP              reduce using rule 52 (id -> type .)
    ELSE            reduce using rule 52 (id -> type .)
    SC              reduce using rule 52 (id -> type .)
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21

    int                            shift and go to state 68
    string                         shift and go to state 69

state 36

    (56) type -> NAME .

    DIGIT           reduce using rule 56 (type -> NAME .)
    CHARACTER       reduce using rule 56 (type -> NAME .)
    LP              reduce using rule 56 (type -> NAME .)
    TIMES           reduce using rule 56 (type -> NAME .)
    DIVIDE          reduce using rule 56 (type -> NAME .)
    EQ              reduce using rule 56 (type -> NAME .)
    NEQ             reduce using rule 56 (type -> NAME .)
    LT              reduce using rule 56 (type -> NAME .)
    GT              reduce using rule 56 (type -> NAME .)
    LEQ             reduce using rule 56 (type -> NAME .)
    GEQ             reduce using rule 56 (type -> NAME .)
    AND             reduce using rule 56 (type -> NAME .)
    OR              reduce using rule 56 (type -> NAME .)
    PLUS            reduce using rule 56 (type -> NAME .)
    MINUS           reduce using rule 56 (type -> NAME .)
    COMMA           reduce using rule 56 (type -> NAME .)
    $end            reduce using rule 56 (type -> NAME .)
    THEN            reduce using rule 56 (type -> NAME .)
    ASSIGN          reduce using rule 56 (type -> NAME .)
    TO              reduce using rule 56 (type -> NAME .)
    RP              reduce using rule 56 (type -> NAME .)
    ELSE            reduce using rule 56 (type -> NAME .)
    SC              reduce using rule 56 (type -> NAME .)


state 37

    (57) type -> REGION .

    DIGIT           reduce using rule 57 (type -> REGION .)
    CHARACTER       reduce using rule 57 (type -> REGION .)
    LP              reduce using rule 57 (type -> REGION .)
    TIMES           reduce using rule 57 (type -> REGION .)
    DIVIDE          reduce using rule 57 (type -> REGION .)
    EQ              reduce using rule 57 (type -> REGION .)
    NEQ             reduce using rule 57 (type -> REGION .)
    LT              reduce using rule 57 (type -> REGION .)
    GT              reduce using rule 57 (type -> REGION .)
    LEQ             reduce using rule 57 (type -> REGION .)
    GEQ             reduce using rule 57 (type -> REGION .)
    AND             reduce using rule 57 (type -> REGION .)
    OR              reduce using rule 57 (type -> REGION .)
    PLUS            reduce using rule 57 (type -> REGION .)
    MINUS           reduce using rule 57 (type -> REGION .)
    COMMA           reduce using rule 57 (type -> REGION .)
    $end            reduce using rule 57 (type -> REGION .)
    THEN            reduce using rule 57 (type -> REGION .)
    ASSIGN          reduce using rule 57 (type -> REGION .)
    TO              reduce using rule 57 (type -> REGION .)
    RP              reduce using rule 57 (type -> REGION .)
    ELSE            reduce using rule 57 (type -> REGION .)
    SC              reduce using rule 57 (type -> REGION .)


state 38

    (58) type -> SERVER .

    DIGIT           reduce using rule 58 (type -> SERVER .)
    CHARACTER       reduce using rule 58 (type -> SERVER .)
    LP              reduce using rule 58 (type -> SERVER .)
    TIMES           reduce using rule 58 (type -> SERVER .)
    DIVIDE          reduce using rule 58 (type -> SERVER .)
    EQ              reduce using rule 58 (type -> SERVER .)
    NEQ             reduce using rule 58 (type -> SERVER .)
    LT              reduce using rule 58 (type -> SERVER .)
    GT              reduce using rule 58 (type -> SERVER .)
    LEQ             reduce using rule 58 (type -> SERVER .)
    GEQ             reduce using rule 58 (type -> SERVER .)
    AND             reduce using rule 58 (type -> SERVER .)
    OR              reduce using rule 58 (type -> SERVER .)
    PLUS            reduce using rule 58 (type -> SERVER .)
    MINUS           reduce using rule 58 (type -> SERVER .)
    COMMA           reduce using rule 58 (type -> SERVER .)
    $end            reduce using rule 58 (type -> SERVER .)
    THEN            reduce using rule 58 (type -> SERVER .)
    ASSIGN          reduce using rule 58 (type -> SERVER .)
    TO              reduce using rule 58 (type -> SERVER .)
    RP              reduce using rule 58 (type -> SERVER .)
    ELSE            reduce using rule 58 (type -> SERVER .)
    SC              reduce using rule 58 (type -> SERVER .)


state 39

    (59) type -> OS .

    DIGIT           reduce using rule 59 (type -> OS .)
    CHARACTER       reduce using rule 59 (type -> OS .)
    LP              reduce using rule 59 (type -> OS .)
    TIMES           reduce using rule 59 (type -> OS .)
    DIVIDE          reduce using rule 59 (type -> OS .)
    EQ              reduce using rule 59 (type -> OS .)
    NEQ             reduce using rule 59 (type -> OS .)
    LT              reduce using rule 59 (type -> OS .)
    GT              reduce using rule 59 (type -> OS .)
    LEQ             reduce using rule 59 (type -> OS .)
    GEQ             reduce using rule 59 (type -> OS .)
    AND             reduce using rule 59 (type -> OS .)
    OR              reduce using rule 59 (type -> OS .)
    PLUS            reduce using rule 59 (type -> OS .)
    MINUS           reduce using rule 59 (type -> OS .)
    COMMA           reduce using rule 59 (type -> OS .)
    $end            reduce using rule 59 (type -> OS .)
    THEN            reduce using rule 59 (type -> OS .)
    ASSIGN          reduce using rule 59 (type -> OS .)
    TO              reduce using rule 59 (type -> OS .)
    RP              reduce using rule 59 (type -> OS .)
    ELSE            reduce using rule 59 (type -> OS .)
    SC              reduce using rule 59 (type -> OS .)


state 40

    (60) type -> ID .

    DIGIT           reduce using rule 60 (type -> ID .)
    CHARACTER       reduce using rule 60 (type -> ID .)
    LP              reduce using rule 60 (type -> ID .)
    TIMES           reduce using rule 60 (type -> ID .)
    DIVIDE          reduce using rule 60 (type -> ID .)
    EQ              reduce using rule 60 (type -> ID .)
    NEQ             reduce using rule 60 (type -> ID .)
    LT              reduce using rule 60 (type -> ID .)
    GT              reduce using rule 60 (type -> ID .)
    LEQ             reduce using rule 60 (type -> ID .)
    GEQ             reduce using rule 60 (type -> ID .)
    AND             reduce using rule 60 (type -> ID .)
    OR              reduce using rule 60 (type -> ID .)
    PLUS            reduce using rule 60 (type -> ID .)
    MINUS           reduce using rule 60 (type -> ID .)
    COMMA           reduce using rule 60 (type -> ID .)
    $end            reduce using rule 60 (type -> ID .)
    THEN            reduce using rule 60 (type -> ID .)
    ASSIGN          reduce using rule 60 (type -> ID .)
    TO              reduce using rule 60 (type -> ID .)
    RP              reduce using rule 60 (type -> ID .)
    ELSE            reduce using rule 60 (type -> ID .)
    SC              reduce using rule 60 (type -> ID .)


state 41

    (61) type -> TAG .

    DIGIT           reduce using rule 61 (type -> TAG .)
    CHARACTER       reduce using rule 61 (type -> TAG .)
    LP              reduce using rule 61 (type -> TAG .)
    TIMES           reduce using rule 61 (type -> TAG .)
    DIVIDE          reduce using rule 61 (type -> TAG .)
    EQ              reduce using rule 61 (type -> TAG .)
    NEQ             reduce using rule 61 (type -> TAG .)
    LT              reduce using rule 61 (type -> TAG .)
    GT              reduce using rule 61 (type -> TAG .)
    LEQ             reduce using rule 61 (type -> TAG .)
    GEQ             reduce using rule 61 (type -> TAG .)
    AND             reduce using rule 61 (type -> TAG .)
    OR              reduce using rule 61 (type -> TAG .)
    PLUS            reduce using rule 61 (type -> TAG .)
    MINUS           reduce using rule 61 (type -> TAG .)
    COMMA           reduce using rule 61 (type -> TAG .)
    $end            reduce using rule 61 (type -> TAG .)
    THEN            reduce using rule 61 (type -> TAG .)
    ASSIGN          reduce using rule 61 (type -> TAG .)
    TO              reduce using rule 61 (type -> TAG .)
    RP              reduce using rule 61 (type -> TAG .)
    ELSE            reduce using rule 61 (type -> TAG .)
    SC              reduce using rule 61 (type -> TAG .)


state 42

    (4) propexplist -> exp COMMA . propexplist
    (3) propexplist -> . exp
    (4) propexplist -> . exp COMMA propexplist
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for $end resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for RP resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    $end            reduce using rule 55 (type -> .)
    RP              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! COMMA           [ reduce using rule 66 (empty -> .) ]
  ! $end            [ reduce using rule 66 (empty -> .) ]
  ! RP              [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    exp                            shift and go to state 4
    propexplist                    shift and go to state 70
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 43

    (6) exp -> term binop . exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for $end resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for THEN resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for RP resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for SC resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    $end            reduce using rule 55 (type -> .)
    THEN            reduce using rule 55 (type -> .)
    RP              reduce using rule 55 (type -> .)
    ELSE            reduce using rule 55 (type -> .)
    SC              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! COMMA           [ reduce using rule 66 (empty -> .) ]
  ! $end            [ reduce using rule 66 (empty -> .) ]
  ! THEN            [ reduce using rule 66 (empty -> .) ]
  ! RP              [ reduce using rule 66 (empty -> .) ]
  ! ELSE            [ reduce using rule 66 (empty -> .) ]
  ! SC              [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    term                           shift and go to state 6
    exp                            shift and go to state 71
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 44

    (30) binop -> sign .

    IF              reduce using rule 30 (binop -> sign .)
    LET             reduce using rule 30 (binop -> sign .)
    MAP             reduce using rule 30 (binop -> sign .)
    TILDE           reduce using rule 30 (binop -> sign .)
    LP              reduce using rule 30 (binop -> sign .)
    EMPTY           reduce using rule 30 (binop -> sign .)
    DIGIT           reduce using rule 30 (binop -> sign .)
    CHARACTER       reduce using rule 30 (binop -> sign .)
    TRUE            reduce using rule 30 (binop -> sign .)
    FALSE           reduce using rule 30 (binop -> sign .)
    PLUS            reduce using rule 30 (binop -> sign .)
    MINUS           reduce using rule 30 (binop -> sign .)
    NUMQ            reduce using rule 30 (binop -> sign .)
    FUNQ            reduce using rule 30 (binop -> sign .)
    LISTQ           reduce using rule 30 (binop -> sign .)
    EMPTYQ          reduce using rule 30 (binop -> sign .)
    CONSQ           reduce using rule 30 (binop -> sign .)
    CONS            reduce using rule 30 (binop -> sign .)
    FIRST           reduce using rule 30 (binop -> sign .)
    REST            reduce using rule 30 (binop -> sign .)
    ARITY           reduce using rule 30 (binop -> sign .)
    NAME            reduce using rule 30 (binop -> sign .)
    REGION          reduce using rule 30 (binop -> sign .)
    SERVER          reduce using rule 30 (binop -> sign .)
    OS              reduce using rule 30 (binop -> sign .)
    ID              reduce using rule 30 (binop -> sign .)
    TAG             reduce using rule 30 (binop -> sign .)
    TIMES           reduce using rule 30 (binop -> sign .)
    DIVIDE          reduce using rule 30 (binop -> sign .)
    EQ              reduce using rule 30 (binop -> sign .)
    NEQ             reduce using rule 30 (binop -> sign .)
    LT              reduce using rule 30 (binop -> sign .)
    GT              reduce using rule 30 (binop -> sign .)
    LEQ             reduce using rule 30 (binop -> sign .)
    GEQ             reduce using rule 30 (binop -> sign .)
    AND             reduce using rule 30 (binop -> sign .)
    OR              reduce using rule 30 (binop -> sign .)
    COMMA           reduce using rule 30 (binop -> sign .)
    $end            reduce using rule 30 (binop -> sign .)
    THEN            reduce using rule 30 (binop -> sign .)
    RP              reduce using rule 30 (binop -> sign .)
    ELSE            reduce using rule 30 (binop -> sign .)
    SC              reduce using rule 30 (binop -> sign .)


state 45

    (31) binop -> TIMES .

    IF              reduce using rule 31 (binop -> TIMES .)
    LET             reduce using rule 31 (binop -> TIMES .)
    MAP             reduce using rule 31 (binop -> TIMES .)
    TILDE           reduce using rule 31 (binop -> TIMES .)
    LP              reduce using rule 31 (binop -> TIMES .)
    EMPTY           reduce using rule 31 (binop -> TIMES .)
    DIGIT           reduce using rule 31 (binop -> TIMES .)
    CHARACTER       reduce using rule 31 (binop -> TIMES .)
    TRUE            reduce using rule 31 (binop -> TIMES .)
    FALSE           reduce using rule 31 (binop -> TIMES .)
    PLUS            reduce using rule 31 (binop -> TIMES .)
    MINUS           reduce using rule 31 (binop -> TIMES .)
    NUMQ            reduce using rule 31 (binop -> TIMES .)
    FUNQ            reduce using rule 31 (binop -> TIMES .)
    LISTQ           reduce using rule 31 (binop -> TIMES .)
    EMPTYQ          reduce using rule 31 (binop -> TIMES .)
    CONSQ           reduce using rule 31 (binop -> TIMES .)
    CONS            reduce using rule 31 (binop -> TIMES .)
    FIRST           reduce using rule 31 (binop -> TIMES .)
    REST            reduce using rule 31 (binop -> TIMES .)
    ARITY           reduce using rule 31 (binop -> TIMES .)
    NAME            reduce using rule 31 (binop -> TIMES .)
    REGION          reduce using rule 31 (binop -> TIMES .)
    SERVER          reduce using rule 31 (binop -> TIMES .)
    OS              reduce using rule 31 (binop -> TIMES .)
    ID              reduce using rule 31 (binop -> TIMES .)
    TAG             reduce using rule 31 (binop -> TIMES .)
    TIMES           reduce using rule 31 (binop -> TIMES .)
    DIVIDE          reduce using rule 31 (binop -> TIMES .)
    EQ              reduce using rule 31 (binop -> TIMES .)
    NEQ             reduce using rule 31 (binop -> TIMES .)
    LT              reduce using rule 31 (binop -> TIMES .)
    GT              reduce using rule 31 (binop -> TIMES .)
    LEQ             reduce using rule 31 (binop -> TIMES .)
    GEQ             reduce using rule 31 (binop -> TIMES .)
    AND             reduce using rule 31 (binop -> TIMES .)
    OR              reduce using rule 31 (binop -> TIMES .)
    COMMA           reduce using rule 31 (binop -> TIMES .)
    $end            reduce using rule 31 (binop -> TIMES .)
    THEN            reduce using rule 31 (binop -> TIMES .)
    RP              reduce using rule 31 (binop -> TIMES .)
    ELSE            reduce using rule 31 (binop -> TIMES .)
    SC              reduce using rule 31 (binop -> TIMES .)


state 46

    (32) binop -> DIVIDE .

    IF              reduce using rule 32 (binop -> DIVIDE .)
    LET             reduce using rule 32 (binop -> DIVIDE .)
    MAP             reduce using rule 32 (binop -> DIVIDE .)
    TILDE           reduce using rule 32 (binop -> DIVIDE .)
    LP              reduce using rule 32 (binop -> DIVIDE .)
    EMPTY           reduce using rule 32 (binop -> DIVIDE .)
    DIGIT           reduce using rule 32 (binop -> DIVIDE .)
    CHARACTER       reduce using rule 32 (binop -> DIVIDE .)
    TRUE            reduce using rule 32 (binop -> DIVIDE .)
    FALSE           reduce using rule 32 (binop -> DIVIDE .)
    PLUS            reduce using rule 32 (binop -> DIVIDE .)
    MINUS           reduce using rule 32 (binop -> DIVIDE .)
    NUMQ            reduce using rule 32 (binop -> DIVIDE .)
    FUNQ            reduce using rule 32 (binop -> DIVIDE .)
    LISTQ           reduce using rule 32 (binop -> DIVIDE .)
    EMPTYQ          reduce using rule 32 (binop -> DIVIDE .)
    CONSQ           reduce using rule 32 (binop -> DIVIDE .)
    CONS            reduce using rule 32 (binop -> DIVIDE .)
    FIRST           reduce using rule 32 (binop -> DIVIDE .)
    REST            reduce using rule 32 (binop -> DIVIDE .)
    ARITY           reduce using rule 32 (binop -> DIVIDE .)
    NAME            reduce using rule 32 (binop -> DIVIDE .)
    REGION          reduce using rule 32 (binop -> DIVIDE .)
    SERVER          reduce using rule 32 (binop -> DIVIDE .)
    OS              reduce using rule 32 (binop -> DIVIDE .)
    ID              reduce using rule 32 (binop -> DIVIDE .)
    TAG             reduce using rule 32 (binop -> DIVIDE .)
    TIMES           reduce using rule 32 (binop -> DIVIDE .)
    DIVIDE          reduce using rule 32 (binop -> DIVIDE .)
    EQ              reduce using rule 32 (binop -> DIVIDE .)
    NEQ             reduce using rule 32 (binop -> DIVIDE .)
    LT              reduce using rule 32 (binop -> DIVIDE .)
    GT              reduce using rule 32 (binop -> DIVIDE .)
    LEQ             reduce using rule 32 (binop -> DIVIDE .)
    GEQ             reduce using rule 32 (binop -> DIVIDE .)
    AND             reduce using rule 32 (binop -> DIVIDE .)
    OR              reduce using rule 32 (binop -> DIVIDE .)
    COMMA           reduce using rule 32 (binop -> DIVIDE .)
    $end            reduce using rule 32 (binop -> DIVIDE .)
    THEN            reduce using rule 32 (binop -> DIVIDE .)
    RP              reduce using rule 32 (binop -> DIVIDE .)
    ELSE            reduce using rule 32 (binop -> DIVIDE .)
    SC              reduce using rule 32 (binop -> DIVIDE .)


state 47

    (33) binop -> EQ .

    IF              reduce using rule 33 (binop -> EQ .)
    LET             reduce using rule 33 (binop -> EQ .)
    MAP             reduce using rule 33 (binop -> EQ .)
    TILDE           reduce using rule 33 (binop -> EQ .)
    LP              reduce using rule 33 (binop -> EQ .)
    EMPTY           reduce using rule 33 (binop -> EQ .)
    DIGIT           reduce using rule 33 (binop -> EQ .)
    CHARACTER       reduce using rule 33 (binop -> EQ .)
    TRUE            reduce using rule 33 (binop -> EQ .)
    FALSE           reduce using rule 33 (binop -> EQ .)
    PLUS            reduce using rule 33 (binop -> EQ .)
    MINUS           reduce using rule 33 (binop -> EQ .)
    NUMQ            reduce using rule 33 (binop -> EQ .)
    FUNQ            reduce using rule 33 (binop -> EQ .)
    LISTQ           reduce using rule 33 (binop -> EQ .)
    EMPTYQ          reduce using rule 33 (binop -> EQ .)
    CONSQ           reduce using rule 33 (binop -> EQ .)
    CONS            reduce using rule 33 (binop -> EQ .)
    FIRST           reduce using rule 33 (binop -> EQ .)
    REST            reduce using rule 33 (binop -> EQ .)
    ARITY           reduce using rule 33 (binop -> EQ .)
    NAME            reduce using rule 33 (binop -> EQ .)
    REGION          reduce using rule 33 (binop -> EQ .)
    SERVER          reduce using rule 33 (binop -> EQ .)
    OS              reduce using rule 33 (binop -> EQ .)
    ID              reduce using rule 33 (binop -> EQ .)
    TAG             reduce using rule 33 (binop -> EQ .)
    TIMES           reduce using rule 33 (binop -> EQ .)
    DIVIDE          reduce using rule 33 (binop -> EQ .)
    EQ              reduce using rule 33 (binop -> EQ .)
    NEQ             reduce using rule 33 (binop -> EQ .)
    LT              reduce using rule 33 (binop -> EQ .)
    GT              reduce using rule 33 (binop -> EQ .)
    LEQ             reduce using rule 33 (binop -> EQ .)
    GEQ             reduce using rule 33 (binop -> EQ .)
    AND             reduce using rule 33 (binop -> EQ .)
    OR              reduce using rule 33 (binop -> EQ .)
    COMMA           reduce using rule 33 (binop -> EQ .)
    $end            reduce using rule 33 (binop -> EQ .)
    THEN            reduce using rule 33 (binop -> EQ .)
    RP              reduce using rule 33 (binop -> EQ .)
    ELSE            reduce using rule 33 (binop -> EQ .)
    SC              reduce using rule 33 (binop -> EQ .)


state 48

    (34) binop -> NEQ .

    IF              reduce using rule 34 (binop -> NEQ .)
    LET             reduce using rule 34 (binop -> NEQ .)
    MAP             reduce using rule 34 (binop -> NEQ .)
    TILDE           reduce using rule 34 (binop -> NEQ .)
    LP              reduce using rule 34 (binop -> NEQ .)
    EMPTY           reduce using rule 34 (binop -> NEQ .)
    DIGIT           reduce using rule 34 (binop -> NEQ .)
    CHARACTER       reduce using rule 34 (binop -> NEQ .)
    TRUE            reduce using rule 34 (binop -> NEQ .)
    FALSE           reduce using rule 34 (binop -> NEQ .)
    PLUS            reduce using rule 34 (binop -> NEQ .)
    MINUS           reduce using rule 34 (binop -> NEQ .)
    NUMQ            reduce using rule 34 (binop -> NEQ .)
    FUNQ            reduce using rule 34 (binop -> NEQ .)
    LISTQ           reduce using rule 34 (binop -> NEQ .)
    EMPTYQ          reduce using rule 34 (binop -> NEQ .)
    CONSQ           reduce using rule 34 (binop -> NEQ .)
    CONS            reduce using rule 34 (binop -> NEQ .)
    FIRST           reduce using rule 34 (binop -> NEQ .)
    REST            reduce using rule 34 (binop -> NEQ .)
    ARITY           reduce using rule 34 (binop -> NEQ .)
    NAME            reduce using rule 34 (binop -> NEQ .)
    REGION          reduce using rule 34 (binop -> NEQ .)
    SERVER          reduce using rule 34 (binop -> NEQ .)
    OS              reduce using rule 34 (binop -> NEQ .)
    ID              reduce using rule 34 (binop -> NEQ .)
    TAG             reduce using rule 34 (binop -> NEQ .)
    TIMES           reduce using rule 34 (binop -> NEQ .)
    DIVIDE          reduce using rule 34 (binop -> NEQ .)
    EQ              reduce using rule 34 (binop -> NEQ .)
    NEQ             reduce using rule 34 (binop -> NEQ .)
    LT              reduce using rule 34 (binop -> NEQ .)
    GT              reduce using rule 34 (binop -> NEQ .)
    LEQ             reduce using rule 34 (binop -> NEQ .)
    GEQ             reduce using rule 34 (binop -> NEQ .)
    AND             reduce using rule 34 (binop -> NEQ .)
    OR              reduce using rule 34 (binop -> NEQ .)
    COMMA           reduce using rule 34 (binop -> NEQ .)
    $end            reduce using rule 34 (binop -> NEQ .)
    THEN            reduce using rule 34 (binop -> NEQ .)
    RP              reduce using rule 34 (binop -> NEQ .)
    ELSE            reduce using rule 34 (binop -> NEQ .)
    SC              reduce using rule 34 (binop -> NEQ .)


state 49

    (35) binop -> LT .

    IF              reduce using rule 35 (binop -> LT .)
    LET             reduce using rule 35 (binop -> LT .)
    MAP             reduce using rule 35 (binop -> LT .)
    TILDE           reduce using rule 35 (binop -> LT .)
    LP              reduce using rule 35 (binop -> LT .)
    EMPTY           reduce using rule 35 (binop -> LT .)
    DIGIT           reduce using rule 35 (binop -> LT .)
    CHARACTER       reduce using rule 35 (binop -> LT .)
    TRUE            reduce using rule 35 (binop -> LT .)
    FALSE           reduce using rule 35 (binop -> LT .)
    PLUS            reduce using rule 35 (binop -> LT .)
    MINUS           reduce using rule 35 (binop -> LT .)
    NUMQ            reduce using rule 35 (binop -> LT .)
    FUNQ            reduce using rule 35 (binop -> LT .)
    LISTQ           reduce using rule 35 (binop -> LT .)
    EMPTYQ          reduce using rule 35 (binop -> LT .)
    CONSQ           reduce using rule 35 (binop -> LT .)
    CONS            reduce using rule 35 (binop -> LT .)
    FIRST           reduce using rule 35 (binop -> LT .)
    REST            reduce using rule 35 (binop -> LT .)
    ARITY           reduce using rule 35 (binop -> LT .)
    NAME            reduce using rule 35 (binop -> LT .)
    REGION          reduce using rule 35 (binop -> LT .)
    SERVER          reduce using rule 35 (binop -> LT .)
    OS              reduce using rule 35 (binop -> LT .)
    ID              reduce using rule 35 (binop -> LT .)
    TAG             reduce using rule 35 (binop -> LT .)
    TIMES           reduce using rule 35 (binop -> LT .)
    DIVIDE          reduce using rule 35 (binop -> LT .)
    EQ              reduce using rule 35 (binop -> LT .)
    NEQ             reduce using rule 35 (binop -> LT .)
    LT              reduce using rule 35 (binop -> LT .)
    GT              reduce using rule 35 (binop -> LT .)
    LEQ             reduce using rule 35 (binop -> LT .)
    GEQ             reduce using rule 35 (binop -> LT .)
    AND             reduce using rule 35 (binop -> LT .)
    OR              reduce using rule 35 (binop -> LT .)
    COMMA           reduce using rule 35 (binop -> LT .)
    $end            reduce using rule 35 (binop -> LT .)
    THEN            reduce using rule 35 (binop -> LT .)
    RP              reduce using rule 35 (binop -> LT .)
    ELSE            reduce using rule 35 (binop -> LT .)
    SC              reduce using rule 35 (binop -> LT .)


state 50

    (36) binop -> GT .

    IF              reduce using rule 36 (binop -> GT .)
    LET             reduce using rule 36 (binop -> GT .)
    MAP             reduce using rule 36 (binop -> GT .)
    TILDE           reduce using rule 36 (binop -> GT .)
    LP              reduce using rule 36 (binop -> GT .)
    EMPTY           reduce using rule 36 (binop -> GT .)
    DIGIT           reduce using rule 36 (binop -> GT .)
    CHARACTER       reduce using rule 36 (binop -> GT .)
    TRUE            reduce using rule 36 (binop -> GT .)
    FALSE           reduce using rule 36 (binop -> GT .)
    PLUS            reduce using rule 36 (binop -> GT .)
    MINUS           reduce using rule 36 (binop -> GT .)
    NUMQ            reduce using rule 36 (binop -> GT .)
    FUNQ            reduce using rule 36 (binop -> GT .)
    LISTQ           reduce using rule 36 (binop -> GT .)
    EMPTYQ          reduce using rule 36 (binop -> GT .)
    CONSQ           reduce using rule 36 (binop -> GT .)
    CONS            reduce using rule 36 (binop -> GT .)
    FIRST           reduce using rule 36 (binop -> GT .)
    REST            reduce using rule 36 (binop -> GT .)
    ARITY           reduce using rule 36 (binop -> GT .)
    NAME            reduce using rule 36 (binop -> GT .)
    REGION          reduce using rule 36 (binop -> GT .)
    SERVER          reduce using rule 36 (binop -> GT .)
    OS              reduce using rule 36 (binop -> GT .)
    ID              reduce using rule 36 (binop -> GT .)
    TAG             reduce using rule 36 (binop -> GT .)
    TIMES           reduce using rule 36 (binop -> GT .)
    DIVIDE          reduce using rule 36 (binop -> GT .)
    EQ              reduce using rule 36 (binop -> GT .)
    NEQ             reduce using rule 36 (binop -> GT .)
    LT              reduce using rule 36 (binop -> GT .)
    GT              reduce using rule 36 (binop -> GT .)
    LEQ             reduce using rule 36 (binop -> GT .)
    GEQ             reduce using rule 36 (binop -> GT .)
    AND             reduce using rule 36 (binop -> GT .)
    OR              reduce using rule 36 (binop -> GT .)
    COMMA           reduce using rule 36 (binop -> GT .)
    $end            reduce using rule 36 (binop -> GT .)
    THEN            reduce using rule 36 (binop -> GT .)
    RP              reduce using rule 36 (binop -> GT .)
    ELSE            reduce using rule 36 (binop -> GT .)
    SC              reduce using rule 36 (binop -> GT .)


state 51

    (37) binop -> LEQ .

    IF              reduce using rule 37 (binop -> LEQ .)
    LET             reduce using rule 37 (binop -> LEQ .)
    MAP             reduce using rule 37 (binop -> LEQ .)
    TILDE           reduce using rule 37 (binop -> LEQ .)
    LP              reduce using rule 37 (binop -> LEQ .)
    EMPTY           reduce using rule 37 (binop -> LEQ .)
    DIGIT           reduce using rule 37 (binop -> LEQ .)
    CHARACTER       reduce using rule 37 (binop -> LEQ .)
    TRUE            reduce using rule 37 (binop -> LEQ .)
    FALSE           reduce using rule 37 (binop -> LEQ .)
    PLUS            reduce using rule 37 (binop -> LEQ .)
    MINUS           reduce using rule 37 (binop -> LEQ .)
    NUMQ            reduce using rule 37 (binop -> LEQ .)
    FUNQ            reduce using rule 37 (binop -> LEQ .)
    LISTQ           reduce using rule 37 (binop -> LEQ .)
    EMPTYQ          reduce using rule 37 (binop -> LEQ .)
    CONSQ           reduce using rule 37 (binop -> LEQ .)
    CONS            reduce using rule 37 (binop -> LEQ .)
    FIRST           reduce using rule 37 (binop -> LEQ .)
    REST            reduce using rule 37 (binop -> LEQ .)
    ARITY           reduce using rule 37 (binop -> LEQ .)
    NAME            reduce using rule 37 (binop -> LEQ .)
    REGION          reduce using rule 37 (binop -> LEQ .)
    SERVER          reduce using rule 37 (binop -> LEQ .)
    OS              reduce using rule 37 (binop -> LEQ .)
    ID              reduce using rule 37 (binop -> LEQ .)
    TAG             reduce using rule 37 (binop -> LEQ .)
    TIMES           reduce using rule 37 (binop -> LEQ .)
    DIVIDE          reduce using rule 37 (binop -> LEQ .)
    EQ              reduce using rule 37 (binop -> LEQ .)
    NEQ             reduce using rule 37 (binop -> LEQ .)
    LT              reduce using rule 37 (binop -> LEQ .)
    GT              reduce using rule 37 (binop -> LEQ .)
    LEQ             reduce using rule 37 (binop -> LEQ .)
    GEQ             reduce using rule 37 (binop -> LEQ .)
    AND             reduce using rule 37 (binop -> LEQ .)
    OR              reduce using rule 37 (binop -> LEQ .)
    COMMA           reduce using rule 37 (binop -> LEQ .)
    $end            reduce using rule 37 (binop -> LEQ .)
    THEN            reduce using rule 37 (binop -> LEQ .)
    RP              reduce using rule 37 (binop -> LEQ .)
    ELSE            reduce using rule 37 (binop -> LEQ .)
    SC              reduce using rule 37 (binop -> LEQ .)


state 52

    (38) binop -> GEQ .

    IF              reduce using rule 38 (binop -> GEQ .)
    LET             reduce using rule 38 (binop -> GEQ .)
    MAP             reduce using rule 38 (binop -> GEQ .)
    TILDE           reduce using rule 38 (binop -> GEQ .)
    LP              reduce using rule 38 (binop -> GEQ .)
    EMPTY           reduce using rule 38 (binop -> GEQ .)
    DIGIT           reduce using rule 38 (binop -> GEQ .)
    CHARACTER       reduce using rule 38 (binop -> GEQ .)
    TRUE            reduce using rule 38 (binop -> GEQ .)
    FALSE           reduce using rule 38 (binop -> GEQ .)
    PLUS            reduce using rule 38 (binop -> GEQ .)
    MINUS           reduce using rule 38 (binop -> GEQ .)
    NUMQ            reduce using rule 38 (binop -> GEQ .)
    FUNQ            reduce using rule 38 (binop -> GEQ .)
    LISTQ           reduce using rule 38 (binop -> GEQ .)
    EMPTYQ          reduce using rule 38 (binop -> GEQ .)
    CONSQ           reduce using rule 38 (binop -> GEQ .)
    CONS            reduce using rule 38 (binop -> GEQ .)
    FIRST           reduce using rule 38 (binop -> GEQ .)
    REST            reduce using rule 38 (binop -> GEQ .)
    ARITY           reduce using rule 38 (binop -> GEQ .)
    NAME            reduce using rule 38 (binop -> GEQ .)
    REGION          reduce using rule 38 (binop -> GEQ .)
    SERVER          reduce using rule 38 (binop -> GEQ .)
    OS              reduce using rule 38 (binop -> GEQ .)
    ID              reduce using rule 38 (binop -> GEQ .)
    TAG             reduce using rule 38 (binop -> GEQ .)
    TIMES           reduce using rule 38 (binop -> GEQ .)
    DIVIDE          reduce using rule 38 (binop -> GEQ .)
    EQ              reduce using rule 38 (binop -> GEQ .)
    NEQ             reduce using rule 38 (binop -> GEQ .)
    LT              reduce using rule 38 (binop -> GEQ .)
    GT              reduce using rule 38 (binop -> GEQ .)
    LEQ             reduce using rule 38 (binop -> GEQ .)
    GEQ             reduce using rule 38 (binop -> GEQ .)
    AND             reduce using rule 38 (binop -> GEQ .)
    OR              reduce using rule 38 (binop -> GEQ .)
    COMMA           reduce using rule 38 (binop -> GEQ .)
    $end            reduce using rule 38 (binop -> GEQ .)
    THEN            reduce using rule 38 (binop -> GEQ .)
    RP              reduce using rule 38 (binop -> GEQ .)
    ELSE            reduce using rule 38 (binop -> GEQ .)
    SC              reduce using rule 38 (binop -> GEQ .)


state 53

    (39) binop -> AND .

    IF              reduce using rule 39 (binop -> AND .)
    LET             reduce using rule 39 (binop -> AND .)
    MAP             reduce using rule 39 (binop -> AND .)
    TILDE           reduce using rule 39 (binop -> AND .)
    LP              reduce using rule 39 (binop -> AND .)
    EMPTY           reduce using rule 39 (binop -> AND .)
    DIGIT           reduce using rule 39 (binop -> AND .)
    CHARACTER       reduce using rule 39 (binop -> AND .)
    TRUE            reduce using rule 39 (binop -> AND .)
    FALSE           reduce using rule 39 (binop -> AND .)
    PLUS            reduce using rule 39 (binop -> AND .)
    MINUS           reduce using rule 39 (binop -> AND .)
    NUMQ            reduce using rule 39 (binop -> AND .)
    FUNQ            reduce using rule 39 (binop -> AND .)
    LISTQ           reduce using rule 39 (binop -> AND .)
    EMPTYQ          reduce using rule 39 (binop -> AND .)
    CONSQ           reduce using rule 39 (binop -> AND .)
    CONS            reduce using rule 39 (binop -> AND .)
    FIRST           reduce using rule 39 (binop -> AND .)
    REST            reduce using rule 39 (binop -> AND .)
    ARITY           reduce using rule 39 (binop -> AND .)
    NAME            reduce using rule 39 (binop -> AND .)
    REGION          reduce using rule 39 (binop -> AND .)
    SERVER          reduce using rule 39 (binop -> AND .)
    OS              reduce using rule 39 (binop -> AND .)
    ID              reduce using rule 39 (binop -> AND .)
    TAG             reduce using rule 39 (binop -> AND .)
    TIMES           reduce using rule 39 (binop -> AND .)
    DIVIDE          reduce using rule 39 (binop -> AND .)
    EQ              reduce using rule 39 (binop -> AND .)
    NEQ             reduce using rule 39 (binop -> AND .)
    LT              reduce using rule 39 (binop -> AND .)
    GT              reduce using rule 39 (binop -> AND .)
    LEQ             reduce using rule 39 (binop -> AND .)
    GEQ             reduce using rule 39 (binop -> AND .)
    AND             reduce using rule 39 (binop -> AND .)
    OR              reduce using rule 39 (binop -> AND .)
    COMMA           reduce using rule 39 (binop -> AND .)
    $end            reduce using rule 39 (binop -> AND .)
    THEN            reduce using rule 39 (binop -> AND .)
    RP              reduce using rule 39 (binop -> AND .)
    ELSE            reduce using rule 39 (binop -> AND .)
    SC              reduce using rule 39 (binop -> AND .)


state 54

    (40) binop -> OR .

    IF              reduce using rule 40 (binop -> OR .)
    LET             reduce using rule 40 (binop -> OR .)
    MAP             reduce using rule 40 (binop -> OR .)
    TILDE           reduce using rule 40 (binop -> OR .)
    LP              reduce using rule 40 (binop -> OR .)
    EMPTY           reduce using rule 40 (binop -> OR .)
    DIGIT           reduce using rule 40 (binop -> OR .)
    CHARACTER       reduce using rule 40 (binop -> OR .)
    TRUE            reduce using rule 40 (binop -> OR .)
    FALSE           reduce using rule 40 (binop -> OR .)
    PLUS            reduce using rule 40 (binop -> OR .)
    MINUS           reduce using rule 40 (binop -> OR .)
    NUMQ            reduce using rule 40 (binop -> OR .)
    FUNQ            reduce using rule 40 (binop -> OR .)
    LISTQ           reduce using rule 40 (binop -> OR .)
    EMPTYQ          reduce using rule 40 (binop -> OR .)
    CONSQ           reduce using rule 40 (binop -> OR .)
    CONS            reduce using rule 40 (binop -> OR .)
    FIRST           reduce using rule 40 (binop -> OR .)
    REST            reduce using rule 40 (binop -> OR .)
    ARITY           reduce using rule 40 (binop -> OR .)
    NAME            reduce using rule 40 (binop -> OR .)
    REGION          reduce using rule 40 (binop -> OR .)
    SERVER          reduce using rule 40 (binop -> OR .)
    OS              reduce using rule 40 (binop -> OR .)
    ID              reduce using rule 40 (binop -> OR .)
    TAG             reduce using rule 40 (binop -> OR .)
    TIMES           reduce using rule 40 (binop -> OR .)
    DIVIDE          reduce using rule 40 (binop -> OR .)
    EQ              reduce using rule 40 (binop -> OR .)
    NEQ             reduce using rule 40 (binop -> OR .)
    LT              reduce using rule 40 (binop -> OR .)
    GT              reduce using rule 40 (binop -> OR .)
    LEQ             reduce using rule 40 (binop -> OR .)
    GEQ             reduce using rule 40 (binop -> OR .)
    AND             reduce using rule 40 (binop -> OR .)
    OR              reduce using rule 40 (binop -> OR .)
    COMMA           reduce using rule 40 (binop -> OR .)
    $end            reduce using rule 40 (binop -> OR .)
    THEN            reduce using rule 40 (binop -> OR .)
    RP              reduce using rule 40 (binop -> OR .)
    ELSE            reduce using rule 40 (binop -> OR .)
    SC              reduce using rule 40 (binop -> OR .)


state 55

    (7) exp -> IF exp . THEN exp ELSE exp

    THEN            shift and go to state 72


state 56

    (13) term -> empty .

    TIMES           reduce using rule 13 (term -> empty .)
    DIVIDE          reduce using rule 13 (term -> empty .)
    EQ              reduce using rule 13 (term -> empty .)
    NEQ             reduce using rule 13 (term -> empty .)
    LT              reduce using rule 13 (term -> empty .)
    GT              reduce using rule 13 (term -> empty .)
    LEQ             reduce using rule 13 (term -> empty .)
    GEQ             reduce using rule 13 (term -> empty .)
    AND             reduce using rule 13 (term -> empty .)
    OR              reduce using rule 13 (term -> empty .)
    PLUS            reduce using rule 13 (term -> empty .)
    MINUS           reduce using rule 13 (term -> empty .)
    THEN            reduce using rule 13 (term -> empty .)
    COMMA           reduce using rule 13 (term -> empty .)
    $end            reduce using rule 13 (term -> empty .)
    RP              reduce using rule 13 (term -> empty .)
    ELSE            reduce using rule 13 (term -> empty .)
    SC              reduce using rule 13 (term -> empty .)


state 57

    (8) exp -> LET def . IN exp

    IN              shift and go to state 73


state 58

    (20) def -> id . ASSIGN exp SC
    (21) def -> id . ASSIGN exp SC def

    ASSIGN          shift and go to state 74


state 59

    (9) exp -> MAP idlist . TO exp

    TO              shift and go to state 75


state 60

    (22) idlist -> propidlist .

    TO              reduce using rule 22 (idlist -> propidlist .)


state 61

    (23) idlist -> empty .

    TO              reduce using rule 23 (idlist -> empty .)


state 62

    (24) propidlist -> id .
    (25) propidlist -> id . COMMA propidlist

    TO              reduce using rule 24 (propidlist -> id .)
    COMMA           shift and go to state 76


state 63

    (10) term -> unop term .

    TIMES           reduce using rule 10 (term -> unop term .)
    DIVIDE          reduce using rule 10 (term -> unop term .)
    EQ              reduce using rule 10 (term -> unop term .)
    NEQ             reduce using rule 10 (term -> unop term .)
    LT              reduce using rule 10 (term -> unop term .)
    GT              reduce using rule 10 (term -> unop term .)
    LEQ             reduce using rule 10 (term -> unop term .)
    GEQ             reduce using rule 10 (term -> unop term .)
    AND             reduce using rule 10 (term -> unop term .)
    OR              reduce using rule 10 (term -> unop term .)
    PLUS            reduce using rule 10 (term -> unop term .)
    MINUS           reduce using rule 10 (term -> unop term .)
    COMMA           reduce using rule 10 (term -> unop term .)
    $end            reduce using rule 10 (term -> unop term .)
    THEN            reduce using rule 10 (term -> unop term .)
    RP              reduce using rule 10 (term -> unop term .)
    ELSE            reduce using rule 10 (term -> unop term .)
    SC              reduce using rule 10 (term -> unop term .)


state 64

    (12) term -> factor LP . explist RP
    (1) explist -> . propexplist
    (2) explist -> . empty
    (3) propexplist -> . exp
    (4) propexplist -> . exp COMMA propexplist
    (66) empty -> .
    (67) empty -> . EMPTY
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for RP resolved using rule 55 (type -> .)
    EMPTY           shift and go to state 5
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    RP              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! RP              [ reduce using rule 66 (empty -> .) ]
  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! COMMA           [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    factor                         shift and go to state 11
    explist                        shift and go to state 77
    propexplist                    shift and go to state 2
    empty                          shift and go to state 3
    exp                            shift and go to state 4
    term                           shift and go to state 6
    unop                           shift and go to state 10
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 65

    (17) factor -> LP exp . RP

    RP              shift and go to state 78


state 66

    (63) int -> DIGIT int .

    TIMES           reduce using rule 63 (int -> DIGIT int .)
    DIVIDE          reduce using rule 63 (int -> DIGIT int .)
    EQ              reduce using rule 63 (int -> DIGIT int .)
    NEQ             reduce using rule 63 (int -> DIGIT int .)
    LT              reduce using rule 63 (int -> DIGIT int .)
    GT              reduce using rule 63 (int -> DIGIT int .)
    LEQ             reduce using rule 63 (int -> DIGIT int .)
    GEQ             reduce using rule 63 (int -> DIGIT int .)
    AND             reduce using rule 63 (int -> DIGIT int .)
    OR              reduce using rule 63 (int -> DIGIT int .)
    PLUS            reduce using rule 63 (int -> DIGIT int .)
    MINUS           reduce using rule 63 (int -> DIGIT int .)
    COMMA           reduce using rule 63 (int -> DIGIT int .)
    $end            reduce using rule 63 (int -> DIGIT int .)
    THEN            reduce using rule 63 (int -> DIGIT int .)
    RP              reduce using rule 63 (int -> DIGIT int .)
    ELSE            reduce using rule 63 (int -> DIGIT int .)
    SC              reduce using rule 63 (int -> DIGIT int .)
    LP              reduce using rule 63 (int -> DIGIT int .)
    ASSIGN          reduce using rule 63 (int -> DIGIT int .)
    TO              reduce using rule 63 (int -> DIGIT int .)


state 67

    (65) string -> CHARACTER string .

    TIMES           reduce using rule 65 (string -> CHARACTER string .)
    DIVIDE          reduce using rule 65 (string -> CHARACTER string .)
    EQ              reduce using rule 65 (string -> CHARACTER string .)
    NEQ             reduce using rule 65 (string -> CHARACTER string .)
    LT              reduce using rule 65 (string -> CHARACTER string .)
    GT              reduce using rule 65 (string -> CHARACTER string .)
    LEQ             reduce using rule 65 (string -> CHARACTER string .)
    GEQ             reduce using rule 65 (string -> CHARACTER string .)
    AND             reduce using rule 65 (string -> CHARACTER string .)
    OR              reduce using rule 65 (string -> CHARACTER string .)
    PLUS            reduce using rule 65 (string -> CHARACTER string .)
    MINUS           reduce using rule 65 (string -> CHARACTER string .)
    COMMA           reduce using rule 65 (string -> CHARACTER string .)
    $end            reduce using rule 65 (string -> CHARACTER string .)
    THEN            reduce using rule 65 (string -> CHARACTER string .)
    RP              reduce using rule 65 (string -> CHARACTER string .)
    ELSE            reduce using rule 65 (string -> CHARACTER string .)
    SC              reduce using rule 65 (string -> CHARACTER string .)
    LP              reduce using rule 65 (string -> CHARACTER string .)
    ASSIGN          reduce using rule 65 (string -> CHARACTER string .)
    TO              reduce using rule 65 (string -> CHARACTER string .)


state 68

    (53) id -> type int .

    LP              reduce using rule 53 (id -> type int .)
    TIMES           reduce using rule 53 (id -> type int .)
    DIVIDE          reduce using rule 53 (id -> type int .)
    EQ              reduce using rule 53 (id -> type int .)
    NEQ             reduce using rule 53 (id -> type int .)
    LT              reduce using rule 53 (id -> type int .)
    GT              reduce using rule 53 (id -> type int .)
    LEQ             reduce using rule 53 (id -> type int .)
    GEQ             reduce using rule 53 (id -> type int .)
    AND             reduce using rule 53 (id -> type int .)
    OR              reduce using rule 53 (id -> type int .)
    PLUS            reduce using rule 53 (id -> type int .)
    MINUS           reduce using rule 53 (id -> type int .)
    COMMA           reduce using rule 53 (id -> type int .)
    $end            reduce using rule 53 (id -> type int .)
    THEN            reduce using rule 53 (id -> type int .)
    ASSIGN          reduce using rule 53 (id -> type int .)
    TO              reduce using rule 53 (id -> type int .)
    RP              reduce using rule 53 (id -> type int .)
    ELSE            reduce using rule 53 (id -> type int .)
    SC              reduce using rule 53 (id -> type int .)


state 69

    (54) id -> type string .

    LP              reduce using rule 54 (id -> type string .)
    TIMES           reduce using rule 54 (id -> type string .)
    DIVIDE          reduce using rule 54 (id -> type string .)
    EQ              reduce using rule 54 (id -> type string .)
    NEQ             reduce using rule 54 (id -> type string .)
    LT              reduce using rule 54 (id -> type string .)
    GT              reduce using rule 54 (id -> type string .)
    LEQ             reduce using rule 54 (id -> type string .)
    GEQ             reduce using rule 54 (id -> type string .)
    AND             reduce using rule 54 (id -> type string .)
    OR              reduce using rule 54 (id -> type string .)
    PLUS            reduce using rule 54 (id -> type string .)
    MINUS           reduce using rule 54 (id -> type string .)
    COMMA           reduce using rule 54 (id -> type string .)
    $end            reduce using rule 54 (id -> type string .)
    THEN            reduce using rule 54 (id -> type string .)
    ASSIGN          reduce using rule 54 (id -> type string .)
    TO              reduce using rule 54 (id -> type string .)
    RP              reduce using rule 54 (id -> type string .)
    ELSE            reduce using rule 54 (id -> type string .)
    SC              reduce using rule 54 (id -> type string .)


state 70

    (4) propexplist -> exp COMMA propexplist .

    $end            reduce using rule 4 (propexplist -> exp COMMA propexplist .)
    RP              reduce using rule 4 (propexplist -> exp COMMA propexplist .)


state 71

    (6) exp -> term binop exp .

    COMMA           reduce using rule 6 (exp -> term binop exp .)
    $end            reduce using rule 6 (exp -> term binop exp .)
    THEN            reduce using rule 6 (exp -> term binop exp .)
    RP              reduce using rule 6 (exp -> term binop exp .)
    ELSE            reduce using rule 6 (exp -> term binop exp .)
    SC              reduce using rule 6 (exp -> term binop exp .)


state 72

    (7) exp -> IF exp THEN . exp ELSE exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for ELSE resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    ELSE            reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! ELSE            [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    exp                            shift and go to state 79
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 73

    (8) exp -> LET def IN . exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for $end resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for THEN resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for RP resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for SC resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    $end            reduce using rule 55 (type -> .)
    THEN            reduce using rule 55 (type -> .)
    RP              reduce using rule 55 (type -> .)
    ELSE            reduce using rule 55 (type -> .)
    SC              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! COMMA           [ reduce using rule 66 (empty -> .) ]
  ! $end            [ reduce using rule 66 (empty -> .) ]
  ! THEN            [ reduce using rule 66 (empty -> .) ]
  ! RP              [ reduce using rule 66 (empty -> .) ]
  ! ELSE            [ reduce using rule 66 (empty -> .) ]
  ! SC              [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    exp                            shift and go to state 80
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 74

    (20) def -> id ASSIGN . exp SC
    (21) def -> id ASSIGN . exp SC def
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for SC resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    SC              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! SC              [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    id                             shift and go to state 19
    exp                            shift and go to state 81
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    type                           shift and go to state 35

state 75

    (9) exp -> MAP idlist TO . exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for $end resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for THEN resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for RP resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for SC resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    $end            reduce using rule 55 (type -> .)
    THEN            reduce using rule 55 (type -> .)
    RP              reduce using rule 55 (type -> .)
    ELSE            reduce using rule 55 (type -> .)
    SC              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! COMMA           [ reduce using rule 66 (empty -> .) ]
  ! $end            [ reduce using rule 66 (empty -> .) ]
  ! THEN            [ reduce using rule 66 (empty -> .) ]
  ! RP              [ reduce using rule 66 (empty -> .) ]
  ! ELSE            [ reduce using rule 66 (empty -> .) ]
  ! SC              [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    exp                            shift and go to state 82
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 76

    (25) propidlist -> id COMMA . propidlist
    (24) propidlist -> . id
    (25) propidlist -> . id COMMA propidlist
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

    DIGIT           reduce using rule 55 (type -> .)
    CHARACTER       reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    TO              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

    id                             shift and go to state 62
    propidlist                     shift and go to state 83
    type                           shift and go to state 35

state 77

    (12) term -> factor LP explist . RP

    RP              shift and go to state 84


state 78

    (17) factor -> LP exp RP .

    LP              reduce using rule 17 (factor -> LP exp RP .)
    TIMES           reduce using rule 17 (factor -> LP exp RP .)
    DIVIDE          reduce using rule 17 (factor -> LP exp RP .)
    EQ              reduce using rule 17 (factor -> LP exp RP .)
    NEQ             reduce using rule 17 (factor -> LP exp RP .)
    LT              reduce using rule 17 (factor -> LP exp RP .)
    GT              reduce using rule 17 (factor -> LP exp RP .)
    LEQ             reduce using rule 17 (factor -> LP exp RP .)
    GEQ             reduce using rule 17 (factor -> LP exp RP .)
    AND             reduce using rule 17 (factor -> LP exp RP .)
    OR              reduce using rule 17 (factor -> LP exp RP .)
    PLUS            reduce using rule 17 (factor -> LP exp RP .)
    MINUS           reduce using rule 17 (factor -> LP exp RP .)
    COMMA           reduce using rule 17 (factor -> LP exp RP .)
    $end            reduce using rule 17 (factor -> LP exp RP .)
    THEN            reduce using rule 17 (factor -> LP exp RP .)
    RP              reduce using rule 17 (factor -> LP exp RP .)
    ELSE            reduce using rule 17 (factor -> LP exp RP .)
    SC              reduce using rule 17 (factor -> LP exp RP .)


state 79

    (7) exp -> IF exp THEN exp . ELSE exp

    ELSE            shift and go to state 85


state 80

    (8) exp -> LET def IN exp .

    COMMA           reduce using rule 8 (exp -> LET def IN exp .)
    $end            reduce using rule 8 (exp -> LET def IN exp .)
    THEN            reduce using rule 8 (exp -> LET def IN exp .)
    RP              reduce using rule 8 (exp -> LET def IN exp .)
    ELSE            reduce using rule 8 (exp -> LET def IN exp .)
    SC              reduce using rule 8 (exp -> LET def IN exp .)


state 81

    (20) def -> id ASSIGN exp . SC
    (21) def -> id ASSIGN exp . SC def

    SC              shift and go to state 86


state 82

    (9) exp -> MAP idlist TO exp .

    COMMA           reduce using rule 9 (exp -> MAP idlist TO exp .)
    $end            reduce using rule 9 (exp -> MAP idlist TO exp .)
    THEN            reduce using rule 9 (exp -> MAP idlist TO exp .)
    RP              reduce using rule 9 (exp -> MAP idlist TO exp .)
    ELSE            reduce using rule 9 (exp -> MAP idlist TO exp .)
    SC              reduce using rule 9 (exp -> MAP idlist TO exp .)


state 83

    (25) propidlist -> id COMMA propidlist .

    TO              reduce using rule 25 (propidlist -> id COMMA propidlist .)


state 84

    (12) term -> factor LP explist RP .

    TIMES           reduce using rule 12 (term -> factor LP explist RP .)
    DIVIDE          reduce using rule 12 (term -> factor LP explist RP .)
    EQ              reduce using rule 12 (term -> factor LP explist RP .)
    NEQ             reduce using rule 12 (term -> factor LP explist RP .)
    LT              reduce using rule 12 (term -> factor LP explist RP .)
    GT              reduce using rule 12 (term -> factor LP explist RP .)
    LEQ             reduce using rule 12 (term -> factor LP explist RP .)
    GEQ             reduce using rule 12 (term -> factor LP explist RP .)
    AND             reduce using rule 12 (term -> factor LP explist RP .)
    OR              reduce using rule 12 (term -> factor LP explist RP .)
    PLUS            reduce using rule 12 (term -> factor LP explist RP .)
    MINUS           reduce using rule 12 (term -> factor LP explist RP .)
    COMMA           reduce using rule 12 (term -> factor LP explist RP .)
    $end            reduce using rule 12 (term -> factor LP explist RP .)
    THEN            reduce using rule 12 (term -> factor LP explist RP .)
    RP              reduce using rule 12 (term -> factor LP explist RP .)
    ELSE            reduce using rule 12 (term -> factor LP explist RP .)
    SC              reduce using rule 12 (term -> factor LP explist RP .)


state 85

    (7) exp -> IF exp THEN exp ELSE . exp
    (5) exp -> . term
    (6) exp -> . term binop exp
    (7) exp -> . IF exp THEN exp ELSE exp
    (8) exp -> . LET def IN exp
    (9) exp -> . MAP idlist TO exp
    (10) term -> . unop term
    (11) term -> . factor
    (12) term -> . factor LP explist RP
    (13) term -> . empty
    (14) term -> . int
    (15) term -> . string
    (16) term -> . bool
    (28) unop -> . sign
    (29) unop -> . TILDE
    (17) factor -> . LP exp RP
    (18) factor -> . prim
    (19) factor -> . id
    (66) empty -> .
    (67) empty -> . EMPTY
    (62) int -> . DIGIT
    (63) int -> . DIGIT int
    (64) string -> . CHARACTER
    (65) string -> . CHARACTER string
    (26) bool -> . TRUE
    (27) bool -> . FALSE
    (41) sign -> . PLUS
    (42) sign -> . MINUS
    (43) prim -> . NUMQ
    (44) prim -> . FUNQ
    (45) prim -> . LISTQ
    (46) prim -> . EMPTYQ
    (47) prim -> . CONSQ
    (48) prim -> . CONS
    (49) prim -> . FIRST
    (50) prim -> . REST
    (51) prim -> . ARITY
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for CHARACTER resolved as shift
  ! shift/reduce conflict for LP resolved as shift
  ! reduce/reduce conflict for TIMES resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for EQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for NEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GT resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for LEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for GEQ resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for AND resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for OR resolved using rule 55 (type -> .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for $end resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for THEN resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for RP resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 55 (type -> .)
  ! reduce/reduce conflict for SC resolved using rule 55 (type -> .)
    IF              shift and go to state 7
    LET             shift and go to state 8
    MAP             shift and go to state 9
    TILDE           shift and go to state 17
    LP              shift and go to state 12
    EMPTY           shift and go to state 5
    DIGIT           shift and go to state 20
    CHARACTER       shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25
    NUMQ            shift and go to state 26
    FUNQ            shift and go to state 27
    LISTQ           shift and go to state 28
    EMPTYQ          shift and go to state 29
    CONSQ           shift and go to state 30
    CONS            shift and go to state 31
    FIRST           shift and go to state 32
    REST            shift and go to state 33
    ARITY           shift and go to state 34
    TIMES           reduce using rule 55 (type -> .)
    DIVIDE          reduce using rule 55 (type -> .)
    EQ              reduce using rule 55 (type -> .)
    NEQ             reduce using rule 55 (type -> .)
    LT              reduce using rule 55 (type -> .)
    GT              reduce using rule 55 (type -> .)
    LEQ             reduce using rule 55 (type -> .)
    GEQ             reduce using rule 55 (type -> .)
    AND             reduce using rule 55 (type -> .)
    OR              reduce using rule 55 (type -> .)
    COMMA           reduce using rule 55 (type -> .)
    $end            reduce using rule 55 (type -> .)
    THEN            reduce using rule 55 (type -> .)
    RP              reduce using rule 55 (type -> .)
    ELSE            reduce using rule 55 (type -> .)
    SC              reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

  ! TIMES           [ reduce using rule 66 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 66 (empty -> .) ]
  ! EQ              [ reduce using rule 66 (empty -> .) ]
  ! NEQ             [ reduce using rule 66 (empty -> .) ]
  ! LT              [ reduce using rule 66 (empty -> .) ]
  ! GT              [ reduce using rule 66 (empty -> .) ]
  ! LEQ             [ reduce using rule 66 (empty -> .) ]
  ! GEQ             [ reduce using rule 66 (empty -> .) ]
  ! AND             [ reduce using rule 66 (empty -> .) ]
  ! OR              [ reduce using rule 66 (empty -> .) ]
  ! PLUS            [ reduce using rule 66 (empty -> .) ]
  ! MINUS           [ reduce using rule 66 (empty -> .) ]
  ! COMMA           [ reduce using rule 66 (empty -> .) ]
  ! $end            [ reduce using rule 66 (empty -> .) ]
  ! THEN            [ reduce using rule 66 (empty -> .) ]
  ! RP              [ reduce using rule 66 (empty -> .) ]
  ! ELSE            [ reduce using rule 66 (empty -> .) ]
  ! SC              [ reduce using rule 66 (empty -> .) ]
  ! DIGIT           [ reduce using rule 55 (type -> .) ]
  ! CHARACTER       [ reduce using rule 55 (type -> .) ]
  ! LP              [ reduce using rule 55 (type -> .) ]
  ! PLUS            [ reduce using rule 55 (type -> .) ]
  ! MINUS           [ reduce using rule 55 (type -> .) ]

    exp                            shift and go to state 87
    term                           shift and go to state 6
    unop                           shift and go to state 10
    factor                         shift and go to state 11
    empty                          shift and go to state 56
    int                            shift and go to state 13
    string                         shift and go to state 14
    bool                           shift and go to state 15
    sign                           shift and go to state 16
    prim                           shift and go to state 18
    id                             shift and go to state 19
    type                           shift and go to state 35

state 86

    (20) def -> id ASSIGN exp SC .
    (21) def -> id ASSIGN exp SC . def
    (20) def -> . id ASSIGN exp SC
    (21) def -> . id ASSIGN exp SC def
    (52) id -> . type
    (53) id -> . type int
    (54) id -> . type string
    (55) type -> .
    (56) type -> . NAME
    (57) type -> . REGION
    (58) type -> . SERVER
    (59) type -> . OS
    (60) type -> . ID
    (61) type -> . TAG

    IN              reduce using rule 20 (def -> id ASSIGN exp SC .)
    DIGIT           reduce using rule 55 (type -> .)
    CHARACTER       reduce using rule 55 (type -> .)
    ASSIGN          reduce using rule 55 (type -> .)
    NAME            shift and go to state 36
    REGION          shift and go to state 37
    SERVER          shift and go to state 38
    OS              shift and go to state 39
    ID              shift and go to state 40
    TAG             shift and go to state 41

    id                             shift and go to state 58
    def                            shift and go to state 88
    type                           shift and go to state 35

state 87

    (7) exp -> IF exp THEN exp ELSE exp .

    COMMA           reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    $end            reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    THEN            reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    RP              reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    ELSE            reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)
    SC              reduce using rule 7 (exp -> IF exp THEN exp ELSE exp .)


state 88

    (21) def -> id ASSIGN exp SC def .

    IN              reduce using rule 21 (def -> id ASSIGN exp SC def .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 0 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 0 resolved as shift
WARNING: shift/reduce conflict for LP in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 7 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 7 resolved as shift
WARNING: shift/reduce conflict for LP in state 7 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 10 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 10 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 10 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 10 resolved as shift
WARNING: shift/reduce conflict for LP in state 10 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 10 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 10 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 12 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 12 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 12 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 12 resolved as shift
WARNING: shift/reduce conflict for LP in state 12 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 12 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 12 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 42 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 42 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 42 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 42 resolved as shift
WARNING: shift/reduce conflict for LP in state 42 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 42 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 42 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 43 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 43 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 43 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 43 resolved as shift
WARNING: shift/reduce conflict for LP in state 43 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 43 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 43 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 64 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 64 resolved as shift
WARNING: shift/reduce conflict for LP in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 72 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 72 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 72 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 72 resolved as shift
WARNING: shift/reduce conflict for LP in state 72 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 72 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 72 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 73 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 73 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 73 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 73 resolved as shift
WARNING: shift/reduce conflict for LP in state 73 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 73 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 73 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 74 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 74 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 74 resolved as shift
WARNING: shift/reduce conflict for LP in state 74 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 74 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 75 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 75 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 75 resolved as shift
WARNING: shift/reduce conflict for LP in state 75 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 75 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 85 resolved as shift
WARNING: shift/reduce conflict for CHARACTER in state 85 resolved as shift
WARNING: shift/reduce conflict for LP in state 85 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (explist -> empty)
WARNING: rejected rule (term -> empty) in state 3
WARNING: reduce/reduce conflict in state 7 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 7
WARNING: reduce/reduce conflict in state 9 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 10
WARNING: reduce/reduce conflict in state 12 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 42 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 42
WARNING: reduce/reduce conflict in state 43 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 43
WARNING: reduce/reduce conflict in state 64 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 64
WARNING: reduce/reduce conflict in state 72 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 72
WARNING: reduce/reduce conflict in state 73 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 73
WARNING: reduce/reduce conflict in state 74 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 74
WARNING: reduce/reduce conflict in state 75 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 75
WARNING: reduce/reduce conflict in state 85 resolved using rule (type -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 85
WARNING: Rule (empty -> <empty>) is never reduced
